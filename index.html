<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Workspace • Curadoria</title>

<!-- Chart.js (gráfico pizza) -->
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<style>
:root{
  --bg:#0f1216;
  --panel:#141923;
  --panel-2:#0f151d;
  --stroke:#222935;
  --text:#e8edf4;
  --muted:#a8b2c1;
  --accent:#86b0ff;
  --accent-2:#6ee7c6;
  --danger:#ff6b6b;
  --warn:#f7c948;
  --ok:#55d88a;
  --neutral:#a0a7b4;
  --radius:12px;
  --shadow:0 14px 36px rgba(0,0,0,.35);
}
*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;background:
    radial-gradient(1200px 600px at 18% -10%, #1b2332 0%, transparent 60%),
    radial-gradient(900px 520px at 88% -20%, #171f2b 0%, transparent 60%),
    var(--bg);
  color:var(--text); font:14px/1.6 'Montserrat',-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,"Helvetica Neue",Arial;
}

/* Header */
header{position:sticky; top:0; z-index:30; background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)), var(--panel); border-bottom:1px solid var(--stroke); box-shadow:var(--shadow);}
.header-inner{max-width:min(1920px, 96vw);margin:0 auto;padding:14px 18px; display:flex; align-items:center; gap:16px; justify-content:space-between;}
h1{font-size:18px;margin:0; letter-spacing:.3px}
.header-actions{display:flex; gap:10px; align-items:center}
.btn{
  appearance:none; border:1px solid var(--stroke);
  background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
  color:var(--text); padding:10px 14px; border-radius:10px; cursor:pointer; font-weight:600; letter-spacing:.2px;
}
.btn:hover{box-shadow:0 10px 26px rgba(0,0,0,.3); transform:translateY(-1px)}
.btn.primary{border-color:#4362ff; background:linear-gradient(180deg, rgba(67,98,255,.25), rgba(67,98,255,.12));}

/* Layout */
.container{max-width:min(1920px, 96vw); margin:18px auto; padding:0 18px; display:grid; grid-template-columns: 320px 1fr; gap:18px;}
@media (max-width: 980px){ .container{grid-template-columns:1fr} }
aside{position:sticky; top:76px; align-self:start; background:var(--panel); border:1px solid var(--stroke); border-radius:var(--radius); padding:14px; box-shadow:var(--shadow); max-height:calc(100vh - 92px); overflow:auto;}
.section{margin-bottom:14px}
.section h3{margin:0 0 8px; font-size:12px; font-weight:800; letter-spacing:.35px; color:var(--muted); text-transform:uppercase; text-align:left; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}
.control{display:flex; flex-direction:column; gap:8px}
input[type="text"], select{width:100%; padding:10px 12px; border-radius:10px; border:1px solid var(--stroke); background:var(--panel-2); color:var(--text);}
.filters{display:flex; flex-direction:column; gap:6px; max-height:230px; overflow:auto; padding-right:4px}
.filter-item{display:flex; align-items:center; gap:8px}
.filter-item span{flex:1; min-width:0; overflow:hidden; text-overflow:ellipsis;}
.filter-item input{accent-color:#5aa6ff}
.small{color:var(--muted); font-size:12px}

/* Botão/label elegante para arquivo */
.file-row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
.file-btn{display:inline-flex; align-items:center; gap:8px; cursor:pointer}
.file-btn input{display:none}
#fileName{max-width:180px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap}

/* Painéis */
.panel{background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)), var(--panel); border:1px solid var(--stroke); border-radius:var(--radius); box-shadow:var(--shadow);}
.totals{padding:12px; display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:flex-start;}
.badge{display:inline-flex; align-items:center; gap:8px; border:1px solid var(--stroke); border-radius:999px; padding:8px 12px; background:var(--panel-2);}
.badge .dot{display:inline-block; width:10px; height:10px; border-radius:50%}
.dot.ok{background:var(--ok)}
.dot.err{background:var(--danger)}
.dot.warn{background:var(--warn)}
.dot.inv{background:var(--accent)}
.dot.other{background:var(--neutral)}
.badge b{font-weight:800}
.result-bar{
  display:flex; align-items:center; gap:10px; justify-content:space-between;
  padding:6px 8px; border-top:1px solid var(--stroke);
  position:relative; min-height:30px;
}
.result-actions{ display:flex; align-items:center; gap:8px; }
/* Itens do modal em lista (multiseleção) */
.client-option{ display:flex; align-items:center; gap:8px; padding:8px 10px; border-bottom:1px solid var(--stroke); }
.client-option:last-child{ border-bottom:0; }
.client-option input{ cursor:pointer; }

/* Modal de clientes */
.client-modal{ display:none; position:fixed; inset:0; z-index:1300; }
.client-modal.open{ display:block; }
.client-modal__backdrop{ position:absolute; inset:0; background:rgba(0,0,0,.55); backdrop-filter: blur(2px); }
.client-modal__panel{
  position:relative; margin:10vh auto; width:min(92vw, 520px); max-height:min(78vh, 680px);
  display:flex; flex-direction:column; border:1px solid var(--stroke); border-radius:14px;
  background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.03)), var(--panel);
  box-shadow:0 24px 48px rgba(0,0,0,0.45);
  overflow:hidden; /* mantém header/rodapé visíveis e o scroll só no corpo */
}
.client-modal__head{
  display:flex; align-items:center; justify-content:space-between; gap:10px;
  padding:12px 14px; border-bottom:1px solid var(--stroke); font-weight:800; letter-spacing:.2px;
}
.client-modal__body{
  padding:12px;
  display:flex; flex-direction:column; gap:10px;
  min-height:0; flex:1; overflow:hidden; /* habilita scroll interno sem empurrar o rodapé */
}
.client-modal__search{ height:var(--field-h); border:1px solid var(--stroke); border-radius:10px; padding:0 10px; background:var(--panel-2); display:flex; align-items:center; }
.client-modal__search input{ width:100%; height:calc(var(--field-h) - 12px); line-height:calc(var(--field-h) - 12px); padding:0; border:0; outline:0; background:transparent; color:var(--text); font:inherit; }
.client-modal__list{
  flex:1 1 auto; min-height:0; overflow:auto; overscroll-behavior:contain;
  border:1px solid var(--stroke); border-radius:12px; background:var(--panel-2);
}
.client-modal__item{ width:100%; text-align:left; padding:10px 12px; border:0; background:transparent; color:var(--text); cursor:pointer; font-weight:700; display:block; }
.client-modal__item:hover{ background:rgba(255,255,255,0.04); }
.client-modal__empty{ padding:14px; color:var(--muted); }
.client-modal__foot{ padding:10px 14px; display:flex; justify-content:flex-end; gap:8px; border-top:1px solid var(--stroke); }

/* reforço anti-transbordo e simetria nos cards */
.card-head{display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap; min-width:0;}
.head-left{display:flex; align-items:center; gap:10px; min-width:0;}
.head-right{display:flex; align-items:center; gap:10px; flex-wrap:wrap; min-width:0;}
.block-body{ white-space:pre-wrap; padding:8px 10px; background:#0f141b; overflow:auto; overflow-wrap:anywhere; word-break:break-word; }
.count{color:var(--muted)}

/* Cards */
.cards{ padding:8px; display:grid; grid-template-columns:1fr; gap:8px}
.card{border:1px solid var(--stroke); border-radius:8px; background:var(--panel-2); padding:10px; display:grid; gap:8px; transition:opacity .18s ease, border-color .18s ease; overflow:hidden;}
.card.done{opacity:.55; border-color:#2a3342;}
.card-head{display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap}
.head-left{display:flex; align-items:center; gap:10px}
.head-right{display:flex; align-items:center; gap:10px; flex-wrap:wrap}

/* Código em pill */
.code{
  font-weight:900; letter-spacing:.4px; padding:6px 10px; border-radius:999px;
  border:1px solid rgba(134,176,255,.28);
  background:linear-gradient(180deg, rgba(134,176,255,.10), rgba(134,176,255,.04));
  box-shadow:inset 0 0 0 1px rgba(255,255,255,.04);
}

/* Chips */
.cls-chip{
  font-weight:800; color:var(--text);
  padding:6px 10px; border-radius:999px; border:1px solid var(--stroke);
  background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
}
.cls-ok{ background: rgba(85,216,138,.12); border-color: rgba(85,216,138,.35); }
.cls-err{ background: rgba(255,107,107,.12); border-color: rgba(255,107,107,.35); }
.cls-warn{ background: rgba(247,201,72,.14); border-color: rgba(247,201,72,.38); }
.cls-inv{ background: rgba(134,176,255,.14); border-color: rgba(134,176,255,.38); }
.cls-other{ background: rgba(160,167,180,.12); border-color: rgba(160,167,180,.35); }

/* Tag "Corrigido" */
.corr-chip{
  padding:4px 10px; font-weight:700; border-radius:999px;
  border:1px solid rgba(85,216,138,.35); background:rgba(85,216,138,.12);
  color:var(--text); letter-spacing:.2px;
  min-width:110px;            /* reserva espaço fixo p/ não deslocar o select */
  text-align:center;
  opacity:0; visibility:hidden; transition:opacity .15s ease;
}
.corr-chip.is-on{
  opacity:1; visibility:visible;
}

/* Checkbox estilizado */
.checkbox{
  appearance:none; width:18px; height:18px; border:1px solid var(--stroke); border-radius:6px;
  background:var(--panel); display:inline-grid; place-content:center; cursor:pointer; transition:all .15s ease;
}
.checkbox:focus{ outline:2px solid rgba(67,98,255,.35); outline-offset:2px; }
.checkbox::after{
  content:""; width:12px; height:12px; transform:scale(0); border-radius:3px; background:#4362ff; transition: transform .12s ease;
}
.checkbox:checked{ border-color:#4362ff; background:linear-gradient(180deg, rgba(67,98,255,.25), rgba(67,98,255,.12)); box-shadow:0 6px 18px rgba(67,98,255,.25) inset; }
.checkbox:checked::after{ transform:scale(1); }
.inline-control{display:inline-flex; align-items:center; gap:8px; font-weight:700}

/* Dropdown ao lado da TAG original */
.cls-select{
  background:var(--panel); border:1px solid var(--stroke); color:var(--text);
  padding:8px 10px; border-radius:10px; font-weight:700; min-width:200px;
}
.small-label{color:var(--muted); font-weight:700}

/* Blocos Pergunta/Resposta com título */
.block{
  border:1px solid var(--stroke); border-radius:8px; overflow:hidden; background:var(--panel-2);
}
.block-title{
  padding:6px 10px; font-weight:900; letter-spacing:.3px;
  background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
  border-bottom:1px solid var(--stroke);
  text-align:left;
}
.block-body{ white-space:pre-wrap; padding:8px 10px; background:#0f141b; }

/* Avaliação do Agente */
.eval{border:1px dashed var(--stroke); border-radius:10px; background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02)); padding:10px;}
.eval h4{margin:0 0 8px; font-size:13px; letter-spacing:.2px}
.eval .kv{display:grid; grid-template-columns: 190px 1fr; gap:6px 10px}
.eval .k{color:var(--muted); font-weight:700}
.eval .v{white-space:pre-wrap}

/* Gráfico (compacto, centralizado e recolhível) */
.chart-wrap{padding:10px 12px; border-top:1px solid var(--stroke); display:none}
.chart-wrap.visible{display:block}
.chart-inner{
  display:grid; grid-template-columns:auto 1fr; align-items:center; justify-content:center; gap:18px;
}
.chart-canvas{ display:flex; justify-content:center; align-items:center; }
#pieChart{ width:320px !important; height:180px !important; }
.legend-list{list-style:none; margin:0; padding:0;}
.legend-item{display:flex; align-items:center; gap:8px; margin:4px 0; color:var(--muted)}
.swatch{width:10px; height:10px; border-radius:50%}
.chart-counts{margin-top:8px; color:var(--muted); font-size:12px}

@media (max-width: 980px){
  .chart-inner{ grid-template-columns: 1fr; }
  .legend-list{ display:flex; flex-wrap:wrap; gap:10px; justify-content:center; }
}

/* Divisor por grupo */
.group-sep{ display:flex; align-items:center; gap:10px; margin:18px 12px 6px; grid-column:1 / -1; }
.group-sep .line{flex:1; height:1px; background:var(--stroke); border-radius:1px;}
.group-sep .label{
  padding:6px 10px; border-radius:999px; border:1px solid var(--stroke);
  background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
  font-weight:800; color:var(--muted); letter-spacing:.3px;
}

/* Identificação do cliente (abaixo do separador / dentro do card) */
.client-id{
  margin: 0px 0 0px;
  padding: 0px 0 0;
  color: var(--muted);
  font-size: 14px;
  display: flex;
  gap: 8px;
  align-items: center;
}
.client-id .small-label{ opacity:.9; }
.client-id .client-name{ white-space:nowrap; }
@media (max-width: 980px){ .client-id{ flex-wrap: wrap; } }

/* Estados */
.hidden{display:none !important}

/* Modo foco / compacto */
body.focus aside, body.focus #totalsPanel{display:none !important}
body.focus .container{grid-template-columns:1fr}
body.compact .cards{ gap:8px; padding:8px }
body.compact .card{ padding:10px }
body.compact .badge{ padding:6px 10px }

/* ——— App Switcher ——— */
.app-switcher { position: absolute; right: 16px; top: 16px; z-index: 1000; }
.app-switcher__btn {
  border: 1px solid var(--border, rgba(255,255,255,.15));
  background: linear-gradient(135deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
  color: var(--fg, #e5e7eb);
  padding: 8px 12px; border-radius: 12px; font-weight: 700; letter-spacing: .2px;
  cursor: pointer; box-shadow: 0 8px 24px rgba(0,0,0,.25); backdrop-filter: blur(6px);
}
.app-switcher__btn:hover { transform: translateY(-1px); }
.app-switcher__menu {
  position: absolute; right: 0; margin-top: 8px; min-width: 260px; padding: 8px; border-radius: 14px;
  border: 1px solid var(--border, rgba(255,255,255,.12));
  background: linear-gradient(180deg, rgba(15,23,42,.98), rgba(15,23,42,.95));
  box-shadow: 0 20px 40px rgba(0,0,0,.35);
  display: none;
}
.app-switcher.open .app-switcher__menu { display: block; }
.app-switcher__item {
  display: flex; align-items: center; gap: 10px; padding: 10px 10px; border-radius: 10px; text-decoration: none;
  color: var(--fg, #e5e7eb); border: 1px solid transparent;
}
.app-switcher__item small { color: var(--muted, #9aa4b2); display:block; margin-top:2px }
.app-switcher__item:hover { background: rgba(255,255,255,.04); border-color: rgba(255,255,255,.08); }
header { position: relative; }

/* ——— Ajuda (FAB no canto inferior direito) ——— */
.help-fab{
  position: fixed; right: 18px; bottom: 18px; z-index: 1200;
}
.help-fab .help-hint{
  display:inline-flex; align-items:center; justify-content:center;
  width:36px; height:36px; border-radius:50%;
  border:1px solid rgba(255,255,255,.12);
  background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
  color:#e8edf4; font-weight:800; cursor:pointer;
  box-shadow:0 10px 24px rgba(0,0,0,.35); user-select:none;
}
.help-fab .help-hint:focus{ outline:2px solid rgba(255,255,255,.18); outline-offset:2px }
.help-fab.open .help-bubble{ display:block; }

.help-bubble{
  display:none; position:fixed; right:18px; bottom:68px; z-index:1201;
  width:min(560px, calc(100vw - 36px)); max-height:min(70vh, 680px); overflow:auto;
  padding:14px 16px; border-radius:14px; border:1px solid rgba(255,255,255,.12);
  background:linear-gradient(180deg, rgba(15,23,42,.98), rgba(15,23,42,.95));
  box-shadow:0 24px 48px rgba(0,0,0,.45);
  color:#d9e2ef; font-size:13px; line-height:1.55;
}
.help-bubble h4{ margin:0 0 8px 0; font-size:14px; letter-spacing:.2px }
.help-bubble b{ font-weight:800 }
.help-bubble ol{ margin:6px 0 0 16px; padding:0 }
.help-bubble li{ margin:6px 0 }
.help-bubble .muted{ color:#9aa4b2 }

</style>
<!-- Fontes (igual ao Transmissor) -->
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
<!-- Fonte apenas para a “assinatura” do Workspace -->
<link href="https://fonts.googleapis.com/css2?family=Caveat:wght@600&display=swap" rel="stylesheet">

<style id="theme-override">
  /* ====== Tokens e base visual espelhando o Transmissor ====== */
  :root{
    --bg:#0a0f1a;
    /* mapeando os nomes já usados no Workspace p/ as superfícies do Transmissor */
    --panel:#0c1424;        /* surface   */
    --panel-2:#101a2b;      /* surface2  */
    --stroke:rgba(255,255,255,.10);
    --text:#e7eeff;
    --muted:#9bb0c9;
    --accent1:#60a5fa; --accent2:#a78bfa; --accent3:#22d3ee;
    --grad:linear-gradient(135deg,var(--accent1) 0%, var(--accent2) 50%, var(--accent3) 100%);
    --radius:12px;
    --field-h:40px; --gap:12px;
  }
  html, body{
    min-height:100vh;
    background: radial-gradient(120% 120% at 0% 0%, #0b1220 0%, #070d17 60%);
    color:var(--text);
    font-family:'Montserrat','Segoe UI',Arial,sans-serif;
    font-size:15px;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  }

  /* ====== Remover a barra superior e aproximar o conteúdo ====== */
  header{ display:none !important; } /* esconde “linha superior” c/ Modo Foco/Compacto */
  .title{ display:none !important; }
  .container{ margin-top: 12px !important; }

  /* Sidebar sobe, mantendo respiro */
aside{ top:18px !important; border-color:var(--stroke) !important; background:
    linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02)), var(--panel) !important;
    border-radius:var(--radius) !important; max-height:calc(100vh - 36px) !important; overflow:auto !important; }

  /* ====== Cartões, painéis e acabamentos premium ====== */
    .card, .panel, .box, .section{
    background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)) !important;
    border:1px solid var(--stroke) !important;
    border-radius:8px !important;
    box-shadow:0 12px 32px rgba(0,0,0,.35) !important;
  }
  .card:hover{ transform:translateY(-1px); box-shadow:0 28px 70px rgba(0,0,0,.55); }

  /* fundo dos blocos de pergunta/resposta */
  .block-body, .question pre, .answer pre{
    background:#0b1422 !important;
    border:1px solid var(--stroke) !important;
    border-radius:12px !important;
    padding:12px !important;
  }

  /* ====== Botões padronizados ====== */
  .btn{
    border:1px solid var(--stroke) !important;
    background:linear-gradient(135deg, rgba(255,255,255,.06), rgba(255,255,255,.02)) !important;
    color:var(--text) !important;
    min-height:var(--field-h) !important;
    padding:0 14px !important;
    border-radius:12px !important;
    font-weight:700 !important;
    letter-spacing:.2px !important;
    box-shadow:0 8px 24px rgba(0,0,0,.25) !important;
    backdrop-filter:blur(6px);
  }
  .btn:hover{ transform:translateY(-1px); }
/* Ajuste fino só para o botão de filtro de cliente */
#btnFilterClient, #exportConferencia{
  font-weight:500 !important;   /* sem negrito */
  text-align:left !important;
}
  .btn.primary{
    background:var(--grad) !important;
    border-color:transparent !important;
    color:#05121a !important;  /* contraste igual ao Transmissor */
  }

  /* ====== Campos (inputs/select/textarea) ====== */
  input[type="text"], input[type="number"], input[type="search"], select, textarea{
    height:var(--field-h) !important;
    border:1px solid var(--stroke) !important;
    border-radius:12px !important;
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02)) !important;
    color:var(--text) !important;
  }
  input::placeholder, textarea::placeholder{ color:var(--muted) !important; }
  input:focus, select:focus, textarea:focus{
    outline:2px solid rgba(34,211,238,.25) !important;
    outline-offset:2px !important;
    border-color:rgba(255,255,255,.18) !important;
  }

  /* Badges e chips */
  .badge{ background:linear-gradient(135deg, rgba(255,255,255,.08), rgba(255,255,255,.03));
          border:1px solid var(--stroke); border-radius:10px; }

  /* Checkboxes marcadas com o mesmo “accent” */
  input[type="checkbox"]:checked{
    background-image:var(--grad) !important;
    border-color:transparent !important;
  }

  /* Ajuda (FAB) com o mesmo gradiente do Transmissor */
  .help-fab .help-hint{
    background:var(--grad) !important;
    color:#05121a !important;
    border:none !important;
    box-shadow:0 8px 24px rgba(0,0,0,.35) !important;
  }

  /* “Logo” do Workspace, estilo assinatura, só visual (sem mudar layout) */
  aside::before{
    content:"Workspace Plus";
    display:block;
    margin:6px 6px 0 6px;
    font-family:'Caveat', cursive;
    font-size:26px; line-height:1;
    background:var(--grad);
    -webkit-background-clip:text; background-clip:text;
    color:transparent;
    text-shadow:0 2px 12px rgba(34,211,238,.18);
  }
</style>

<!-- Scrollbar temática, alinhada ao restante do app -->
<style id="ws-scrollbar">
  *{
    scrollbar-width: thin;
    scrollbar-color: rgba(255,255,255,0.22) #121824;
  }
  ::-webkit-scrollbar{
    width:10px;
    height:10px;
  }
  ::-webkit-scrollbar-track{
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02)), #121824;
    border:1px solid var(--stroke);
    border-radius:12px;
  }
  ::-webkit-scrollbar-thumb{
    background: linear-gradient(180deg, rgba(255,255,255,0.12), rgba(255,255,255,0.06));
    border:1px solid var(--stroke);
    border-radius:10px;
    background-clip: padding-box;
  }
  ::-webkit-scrollbar-thumb:hover{
    background: linear-gradient(180deg, rgba(255,255,255,0.16), rgba(255,255,255,0.10));
  }
</style>

<!-- Casca principal igual ao Transmissor (sem alterar estrutura) -->
<style id="ws-shell">
/* --- Padronização da HOME (chips/bolhas uniformes) --- */
.meta-chips{
  display:flex; flex-wrap:wrap; gap:8px; align-items:flex-start;
  font-size:14px; line-height:1.3;
}
.meta-chip{
  display:inline-flex; align-items:center; gap:6px;
  padding:6px 10px; border:1px solid var(--stroke);
  border-radius:999px; background:linear-gradient(180deg, rgba(255,255,255,0.05), rgba(255,255,255,0.02));
}
.meta-chip .k{ font-weight:700; }
.meta-chip .v{ font-weight:400; }
.meta-chip.topic .v{ font-weight:600; } /* leve ênfase no valor de Tópico */

  /* container externo: mesma “caixa” do Transmissor (.cb-dialog) */
  .app-frame{
    width:min(1920px,92vw);
    margin:24px auto;
    padding:24px 24px 28px 96px; /* reserva área p/ menu lateral */
    background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.02)), var(--panel);
    border:4px solid var(--stroke);
    border-radius: var(--radius);
    box-shadow:0 24px 64px rgba(0,0,0,.45);
    position:relative; /* referência p/ barra interna */
  }
  /* neutraliza o app-frame interno duplicado sem quebrar o layout */
  .app-frame > .app-frame{
    display: contents;
  }
</style>
<!-- Side Nav – Estilo (padrão visual do app) -->
<style id="side-nav-style">
  .side-nav{
    position:absolute; left:24px; top:24px; bottom:28px; z-index:1200; /* dentro do container */
    width:56px; padding:8px;
    border:1px solid var(--stroke);
    border-radius:14px;
    background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02)), var(--panel);
    box-shadow:0 14px 36px rgba(0,0,0,35);
    display:flex; flex-direction:column; justify-content:space-between; gap:8px;
    max-height:calc(100vh - 52px); overflow-y:auto; /* impede alongar e fixa o tamanho */
  }
  /* linha fina ao lado da barra, elegante e consistente */
  .side-nav::after{
    content:""; position:absolute; right:-12px; top:0; bottom:0; width:1px;
    background:var(--stroke); border-radius:1px; opacity:.9;
  }
  .side-nav__group{ display:grid; gap:8px; }
  .sn-btn{
    display:grid; place-items:center; width:40px; height:40px;
    border:1px solid var(--stroke); border-radius:12px;
    background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
    color:var(--text); text-decoration:none; cursor:pointer;
    transition:transform .12s ease, box-shadow .12s ease, border-color .12s ease;
  }
  .sn-btn:hover{ transform:translateY(-1px); box-shadow:0 10px 24px rgba(0,0,0,.35); border-color:rgba(255,255,255,.18); }
  .sn-btn:focus{ outline:2px solid rgba(34,211,238,.25); outline-offset:2px; }
  .sn-btn.active{
    background:var(--grad); border-color:transparent; color:#05121a;
    box-shadow:0 8px 24px rgba(0,0,0,.35);
  }
  .sn-btn svg{ width:20px; height:20px; display:block; }
  .sn-sep{ height:1px; background:var(--stroke); border-radius:1px; margin:4px 0; }

  @media (max-width: 900px){
    .side-nav{ display:none; }
    .app-frame{ padding-left:24px !important; } /* quando esconder a barra, volta o padding */
  }
</style>
<style id="side-nav-tweaks">
  .help-fab{ display:none !important; } /* remove bubble flutuante */
</style>

<!-- Overlay da Análise (mensagens/botões centrados no preview) -->
<style id="ray-overlay-style">
  .ray-overlay{ display:none; padding:24px; min-height:260px; }
  .ray-overlay.visible{ display:flex; align-items:center; justify-content:center; }
  .ray-overlay__box{
    width:min(720px, 92%); text-align:center;
    border:1px solid var(--stroke);
    border-radius:12px;
    background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    box-shadow:var(--shadow);
    padding:22px;
  }
  .ray-overlay__title{ font-weight:800; margin:4px 0 12px; letter-spacing:.2px }
  .ray-overlay__actions{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:10px }
</style>
</head>
<body>

<header>
  <div class="header-inner">
    <h1>Workspace</h1>
    <nav class="app-switcher" aria-label="Outros aplicativos">
      <button id="appSwitcherBtn" class="app-switcher__btn" type="button">HDSP CORP. ▾</button>
      <div id="appSwitcherMenu" class="app-switcher__menu" role="menu">
        <a class="app-switcher__item" role="menuitem" href="LINK_DO_ANALISADOR" target="_blank" rel="noopener">
          <div><strong>Analisador</strong><small>Importa JSON e envia os grupos para avaliação</small></div>
        </a>
        <a class="app-switcher__item" role="menuitem" href="LINK_DO_CONVERSOR" target="_blank" rel="noopener">
          <div><strong>Conversor</strong><small>Converte arquivos em TXT, ou gera packs</small></div>
        </a>
      </div>
    </nav>
    <div class="header-actions">
      <button id="focusBtn" class="btn" title="Oculta filtros e totais para focar na leitura">Modo Foco</button>
      <button id="compactBtn" class="btn" title="Reduz espaços para sessões longas">Modo Compacto</button>
    </div>
  </div>
</header>

<div class="app-frame">
  <!-- Side Nav – HTML (atalhos) (agora dentro do container principal) -->
  <nav class="side-nav" aria-label="Atalhos de aplicativos">
    <div class="side-nav__group">
      <!-- Workspace -->
      <a class="sn-btn" data-app="workspace" title="Workspace" href="#">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <rect x="3" y="3" width="8" height="8" rx="2" stroke="currentColor"></rect>
          <rect x="13" y="3" width="8" height="8" rx="2" stroke="currentColor"></rect>
          <rect x="3" y="13" width="8" height="8" rx="2" stroke="currentColor"></rect>
          <rect x="13" y="13" width="8" height="8" rx="2" stroke="currentColor"></rect>
        </svg>
      </a>
      <!-- Conversor (livros) -->
      <a class="sn-btn" data-app="conversor" title="Conversor" href="#">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M5 4h9a2 2 0 0 1 2 2v12a2 2 0 0 0-2-2H5V4z" stroke="currentColor"></path>
          <path d="M5 16h9" stroke="currentColor"></path>
          <path d="M19 6h-3v12h3a2 2 0 0 0 0-4h-1 1a2 2 0 1 0 0-4h-1 1a2 2 0 1 0 0-4z" stroke="currentColor"></path>
        </svg>
      </a>
      <!-- Transmissor (transmissão) -->
      <a class="sn-btn" data-app="transmissor" title="Transmissor" href="#">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <circle cx="12" cy="12" r="2" stroke="currentColor"></circle>
          <path d="M7 7a7 7 0 0 0 0 10" stroke="currentColor"></path>
          <path d="M17 7a7 7 0 0 1 0 10" stroke="currentColor"></path>
          <path d="M4.5 4.5a10 10 0 0 0 0 15" stroke="currentColor"></path>
          <path d="M19.5 4.5a10 10 0 0 1 0 15" stroke="currentColor"></path>
        </svg>
      </a>
    </div>

    <div class="sn-sep" role="separator" aria-hidden="true"></div>

    <!-- NOVO: grupo central – Home e Análise -->
    <div class="side-nav__group">
      <!-- HOME -->
      <a class="sn-btn" id="snHomeBtn" title="Página Inicial" href="#">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M3 11l9-7 9 7" stroke="currentColor"></path>
          <path d="M5 10v10h14V10" stroke="currentColor"></path>
        </svg>
      </a>
      <!-- ANALISE -->
      <a class="sn-btn" id="snAnaliseBtn" title="Análise" href="#">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M4 20V10" stroke="currentColor"></path>
          <path d="M10 20V4" stroke="currentColor"></path>
          <path d="M16 20v-6" stroke="currentColor"></path>
          <path d="M2 20h20" stroke="currentColor"></path>
        </svg>
      </a>
    </div>

    <div class="sn-sep" role="separator" aria-hidden="true"></div>

    <div class="side-nav__group">
      <!-- Ajuda -->
      <a class="sn-btn" data-app="ajuda" title="Ajuda" href="#">
        <svg viewBox="0 0 24 24" fill="none" aria-hidden="true">
          <path d="M12 17v.01M9.09 9a3 3 0 1 1 4.91 2.45c-.67.42-1 1-1 1.55V14" stroke="currentColor" stroke-linecap="round"></path>
          <circle cx="12" cy="12" r="9" stroke="currentColor"></circle>
        </svg>
      </a>
    </div>
  </nav>
  <div class="app-frame">
  <div class="container">
  <aside>
    <div class="section">
      <h3>Arquivo</h3>
      <div class="control file-row">
        <label class="btn file-btn" for="fileInput">Escolher arquivo
          <input type="file" id="fileInput" accept=".json">
        </label>
        <button id="rayImportBtnSide" class="btn hidden" type="button">Importar Arquivo RAY</button>
        <span id="fileName" class="small">Nenhum arquivo selecionado</span>
<span id="rayStatusSide" class="small" style="flex-basis:100%"></span>
      </div>
    </div>

<div class="section" id="filtersUnifiedSection">
  <h3>Filtros</h3>
  <div class="filters-grid" style="display:grid;grid-template-columns:1fr 1fr;gap:10px;">
    <!-- Busca livre -->
    <div class="control" style="grid-column:1 / -1;">
      <input type="text" id="searchBox" placeholder="Pesquisar palavras">
    </div>

    <!-- Busca específica -->
    <div class="control">
      <input type="text" id="searchQ" placeholder="Filtrar em Perguntas">
    </div>
    <div class="control">
      <input type="text" id="searchA" placeholder="Filtrar em Respostas">
    </div>

    <!-- Tópicos (dinâmico) -->
    <div class="control">
      <select id="topicFilter" title="Filtrar por tópico">
        <option value="">Todos os tópicos</option>
      </select>
      <span class="small">Selecione para filtrar por tópico</span>
    </div>

    <!-- Unidade de Negócio (dinâmico) -->
    <div class="control">
      <select id="unitFilter" title="Filtrar por unidade de negócio">
        <option value="">Todas as unidades</option>
      </select>
      <span class="small">O filtro afeta a preview</span>
    </div>

    <!-- Ações de cliente -->
    <div class="control" style="grid-column:1 / -1;display:flex;gap:8px;flex-wrap:wrap;">
      <button id="btnFilterClient" class="btn hidden">Filtrar por cliente</button>
      <button id="btnClearClients" class="btn hidden" title="Remover todos os filtros de cliente">Limpar filtro</button>
    </div>
  </div>
</div>

    <div class="section">
      <h3>Modo dos filtros</h3>
      <div class="control">
        <label class="filter-item">
          <input type="radio" name="filterMode" value="items" checked>
          Mostrar apenas as interações que atendem aos filtros
        </label>
        <label class="filter-item">
          <input type="radio" name="filterMode" value="groups">
          Mostrar grupos das interações que atendem aos filtros
        </label>
      </div>
    </div>

    <div class="section">
      <h3>Classificações</h3>
      <div id="filters" class="filters"></div>
      <div class="small"></div>
    </div>

    <div class="section">
  <h3>Relatórios</h3>
  <div class="control">
    <button id="exportConferencia" class="btn">Relatório de Conferência</button>
    <span class="small"></span>
  </div>
</div>
</aside>

  <main>
    <section id="totalsPanel" class="panel">
      <div class="totals" id="totals"></div>
      <div class="result-bar">
  <div class="count" id="resultCount">0 itens</div>
  <div class="result-actions">
    <button id="btnFilterClient"   class="btn hidden" title="Selecionar um ou mais clientes">Filtrar por cliente</button>
    <button id="btnChart"          class="btn hidden">Exibir gráfico de assertividade</button>
  </div>
</div>

      <div class="chart-wrap" id="chartWrap">
        <div class="chart-inner">
          <div class="chart-canvas">
            <canvas id="pieChart" aria-label="Gráfico de assertividade"></canvas>
          </div>
          <ul class="legend-list" id="chartLegendList"></ul>
        </div>
        <div class="chart-counts" id="chartCounts"></div>
      </div>
    </section>

    <section id="resultsPanel" class="panel" style="margin-top:12px;">
      <div class="cards" id="cards"></div>
    </section>

    <!-- Overlay global (fora dos painéis, visível na HOME e na ANÁLISE) -->
    <div id="rayOverlay" class="ray-overlay hidden">
  <div class="ray-overlay__box">
    <div id="rayOverlayMsg" class="ray-overlay__title">Aguarde, Carregando dados.</div>
    <div id="rayOverlayFiles" class="small" style="margin-top:6px; text-align:left;"></div>
    <div id="rayOverlayActions" class="ray-overlay__actions hidden">
      <button id="rayOverlayExportSepBtn" class="btn primary">Exportar relatório separado</button>
      <button id="rayOverlayExportUniBtn" class="btn primary">Exportar relatório unificado</button>
      <button id="rayOverlayExportDetBtn" class="btn primary">Relatório de Uso detalhado</button>
    </div>
  </div>
</div>
  <!-- Painel principal existente -->
</main>

<!-- Aba ANÁLISE (RAY) -->
<section id="analysisPanel" class="panel hidden" style="margin:18px auto; max-width:min(1920px, 96vw); padding:14px;">
  <div class="section">
    <h3>Arquivo para Análise (RAY)</h3>
    <div class="control">
      <!-- input escondido; o botão abaixo dispara o clique -->
<input id="rayFileInput" type="file" accept=".json" multiple style="display:none">
      <div class="file-row">
        <button id="rayImportBtn" class="btn">Importar Arquivo RAY</button>
        <span id="rayFileName" class="small">Nenhum arquivo selecionado</span>
      </div>
      <div class="file-row" style="gap:8px;flex-wrap:wrap">
  <button id="rayExportCsvSeparateBtn" class="btn primary">Exportar relatório separado</button>
  <button id="rayExportCsvUnifiedBtn" class="btn primary">Exportar relatório unificado</button>
  <button id="rayExportCsvDetailedBtn" class="btn primary">Relatório de Uso detalhado</button>
  <!-- mantém o botão original oculto para reaproveitar o handler existente -->
  <button id="rayExportCsvBtn" class="hidden" type="button" aria-hidden="true" tabindex="-1">Exportar Relatório Ray</button>
</div>
<span class="small">O CSV considera apenas mensagens do cliente (role=user) cujo createdAt−3h esteja no período.</span>
    </div>
  </div>
</section>
  </div>
</div>

<script>
/* ===================== Estado ===================== */
let RAW = null;
let DATA = [];   // [{grupo, codigo, pergunta, resposta, classificacao, classificacaoEmoji, avaliacao:{...}}]
let FILTERS = new Set();
let ALL_CLASSES = [];
let SEARCH = "";
let SEARCH_Q = "";   // novo: busca só em Pergunta
let SEARCH_A = "";   // novo: busca só em Resposta
let CURRENT_FILE_NAME = "";
let pieChart = null;
let FILTER_MODE = 'items'; // 'items' | 'groups'
let CLIENT_FILTERS = new Set(); // conjunto de códigos selecionados (vazio = todos)

/* ======== Análise (RAY): estado, overlay e troca de botões ======== */
let __MODE = 'home';
let __RAY_READY = false;
let __RAY_DATA = null;
let __RAY_ROWS = []; // somente renderizamos quando o usuário pedir
let __RAY_FILES = []; // [{ name, data:{startDateStr,endDateStr,conversations[]} }]
let __RAY_FILE_NAME_OVERRIDE = '';

const snHome = document.getElementById('snHomeBtn');
const snAnal = document.getElementById('snAnaliseBtn');
const fileLbl = document.querySelector('label.file-btn[for="fileInput"]');
const raySideBtn = document.getElementById('rayImportBtnSide');
const exportMainBtn = document.getElementById('exportConferencia');

const rayInp  = document.getElementById('rayFileInput');
const rayBtn  = document.getElementById('rayImportBtn');
const rayExp  = document.getElementById('rayExportCsvBtn'); // oculto (reuso da lógica atual)
const rayExpSepBtn = document.getElementById('rayExportCsvSeparateBtn');
const rayExpUniBtn = document.getElementById('rayExportCsvUnifiedBtn');
const rayExpDetBtn = document.getElementById('rayExportCsvDetailedBtn');

const overlay = document.getElementById('rayOverlay');
const overlayMsg = document.getElementById('rayOverlayMsg');
const overlayAct = document.getElementById('rayOverlayActions');
const overlayShowBtn = document.getElementById('rayShowPreviewBtn');
const overlayExportSepBtn = document.getElementById('rayOverlayExportSepBtn');
const overlayExportUniBtn = document.getElementById('rayOverlayExportUniBtn');
const overlayExportDetBtn = document.getElementById('rayOverlayExportDetBtn');

// ===== unidade de negócio (Análise) =====
let UNIT_FILTER = '';                      // '' = todas
let CLIENTS_INFO = null;                   // Map(code|norm) -> { name, unidade }
function ensureUnitFilterUI(){
  // Se o select já existe no card "Filtros", apenas vincula o evento.
  const existing = document.getElementById('unitFilter');
  if (existing){
    if (!existing.dataset.bound){
      existing.addEventListener('change', ()=>{
        UNIT_FILTER = existing.value || '';
        if (__MODE === 'analysis' && __RAY_READY){
          if (typeof triggerAnalysisPreview === 'function') triggerAnalysisPreview();
        }
        if (typeof render === 'function') render(); // também aplica na HOME
      });
      existing.dataset.bound = '1';
    }
    return;
  }
  // Fallback (comportamento anterior): cria a seção separada
  if (document.getElementById('unitFilterSection')) return;
  const aside = document.querySelector('aside');
  if (!aside) return;
  const sect = document.createElement('div');
  sect.className = 'section'; sect.id = 'unitFilterSection';
  sect.innerHTML = `
    <h3>Unidade de Negócio</h3>
    <div class="control">
      <select id="unitFilter" title="Filtrar por unidade de negócio">
        <option value="">Todas as unidades</option>
      </select>
      <span class="small">O filtro afeta a preview e o CSV RAY.</span>
    </div>`;
  aside.appendChild(sect);

  const sel = sect.querySelector('#unitFilter');
  sel.addEventListener('change', ()=>{
    UNIT_FILTER = sel.value || '';
    if (__MODE === 'analysis' && __RAY_READY){
      if (typeof triggerAnalysisPreview === 'function') triggerAnalysisPreview();
    }
    if (typeof render === 'function') render();
  });
}

async function refreshUnitFilterOptions(){
  const sel = document.getElementById('unitFilter'); if (!sel) return;

  // ➜ Só monta após importação do RAY e clientes carregados da planilha
  if (!__RAY_READY || !__RAY_DATA) return;

  try{
    if (!window.CLIENTS_INFO || !(window.CLIENTS_INFO instanceof Map) || window.CLIENTS_INFO.size === 0){
      if (typeof loadClientMap==='function'){ await loadClientMap(); }
    }
  }catch(e){ /* silencioso */ }

  if (!window.CLIENTS_INFO || !(window.CLIENTS_INFO instanceof Map) || window.CLIENTS_INFO.size === 0) return;

  // sincroniza a referência local usada pelo restante do código
  CLIENTS_INFO = window.CLIENTS_INFO;

  // Coleta unidades a partir dos códigos do ARQUIVO IMPORTADO (RAY) + planilha
  const units = new Set();
  let codes = new Set();

  if (Array.isArray(__RAY_ROWS) && __RAY_ROWS.length){
    // dados já parseados para a Análise
    codes = new Set(__RAY_ROWS.map(r => normCode(String(r.codigo || parseUserId(r.user_id||'').cliente || '').trim())));
  } else if (Array.isArray(__RAY_DATA.conversations)){
    // usa diretamente o arquivo importado
    __RAY_DATA.conversations.forEach(conv=>{
      const uid = String(conv.user_id||'');
      const code = normCode(String((parseUserId(uid).cliente||'')).trim());
      if (code) codes.add(code);
    });
  }

  // Mapeia códigos → unidades via planilha (CLIENTS_INFO)
  for (const code of codes){
    const info = CLIENTS_INFO.get(code) || CLIENTS_INFO.get(normCode(code));
    if (info?.unidade) units.add(String(info.unidade));
  }

  // Se não houver unidades derivadas do arquivo, usa TODAS as da planilha (ainda depende da planilha)
  if (units.size === 0){
    for (const [,info] of CLIENTS_INFO.entries()){
      if (info?.unidade) units.add(String(info.unidade));
    }
  }

  const cur = sel.value;
  sel.innerHTML = `<option value="">Todas as unidades</option>` +
    Array.from(units).sort((a,b)=>a.localeCompare(b,'pt-BR')).map(u => `<option value="${u}">${u}</option>`).join('');
  sel.value = (cur && units.has(cur)) ? cur : '';
}

// sempre visível (HOME e ANÁLISE)
function toggleUnitFilterUI(){
  const sec = document.getElementById('unitFilterSection');
  if (!sec) return;
  sec.style.display = '';
}

/* ====== Filtro por Tópicos (HOME) ====== */
function ensureTopicFilterUI(){
  // Se o select já existe no card "Filtros", apenas vincula o evento.
  const existing = document.getElementById('topicFilter');
  if (existing){
    if (!existing.dataset.bound){
      existing.addEventListener('change', ()=>{
        window.TOPIC_FILTER = existing.value || '';
        if (typeof render === 'function') render();
      });
      existing.dataset.bound = '1';
    }
    return;
  }
  // Fallback (comportamento anterior): cria a seção separada
  const aside = document.querySelector('aside'); if (!aside) return;
  if (document.getElementById('topicFilterSection')) return;
  const sect = document.createElement('div');
  sect.className = 'section'; sect.id = 'topicFilterSection';
  sect.innerHTML = `
    <h3>Tópicos</h3>
    <div class="control">
      <select id="topicFilter">
        <option value="">Todos os tópicos</option>
      </select>
      <span class="small">Selecione para filtrar por tópico</span>
    </div>`;
  aside.appendChild(sect);
  const sel = sect.querySelector('#topicFilter');
  sel.addEventListener('change', ()=>{
    window.TOPIC_FILTER = sel.value || '';
    render();
  });
}

function refreshTopicFilterOptions(){
  const sel = document.getElementById('topicFilter'); if (!sel) return;
  const set = new Set();

  // HOME: coleta dos dados parseados (mais confiável que varrer DOM)
  if (Array.isArray(window.DATA) && window.DATA.length){
    for (const r of window.DATA){
      // Suporta string "TOPICOS/topicos" e também array "topics"
      const raw = String(r.TOPICOS || r.topicos || '').trim();
      if (raw){
        raw.split(/[;|]/).map(s=>s.trim()).filter(Boolean).forEach(t=> set.add(t));
      }
      if (Array.isArray(r.topics) && r.topics.length){
        r.topics.map(String).map(s=>s.trim()).filter(Boolean).forEach(t=> set.add(t));
      }
    }
  }

  const cur = sel.value;
  sel.innerHTML = `<option value="">Todos os tópicos</option>` +
    Array.from(set).sort((a,b)=>a.localeCompare(b,'pt-BR')).map(t=>`<option value="${t}">${t}</option>`).join('');
  sel.value = (cur && set.has(cur)) ? cur : '';
}

function setOverlayVisible(on){ if (!overlay) return; overlay.classList.toggle('hidden', !on); overlay.classList.toggle('visible', !!on); }
function showOverlayLoading(){
  if (!overlay) return;
  setOverlayVisible(true);
  overlayMsg.textContent = 'Aguarde, Carregando dados...';
  overlayAct.classList.add('hidden');
}
function showOverlayReady(){
  if (!overlay) return;
  setOverlayVisible(true);
  overlayMsg.textContent = 'Dados carregados com sucesso';
  const listEl = document.getElementById('rayOverlayFiles');
  if (listEl){
    if (Array.isArray(__RAY_FILES) && __RAY_FILES.length){
      const esc = (s)=> (typeof escapeHtml==='function' ? escapeHtml(String(s)) : String(s));
      listEl.innerHTML = '<div style="margin-top:6px;"><b>Arquivos importados:</b></div>'
        + '<ul style="max-height:180px;overflow:auto;margin:6px 0 0 16px; padding:0;">'
        + __RAY_FILES.map(f=>{
            const bot = (f && f.data && f.data.chatbotName) ? (esc(f.data.chatbotName) + ' — ') : '';
            return `<li>${bot}${esc(f.name)}</li>`;
          }).join('')
        + '</ul>';
    } else {
      listEl.innerHTML = '';
    }
  }
  overlayAct.classList.remove('hidden');
}
function hideOverlay(){ setOverlayVisible(false); }

function clearPreviewUI(){
  const cards = document.getElementById('cards');
  const totals = document.getElementById('totals');
  const resultCount = document.getElementById('resultCount');
  const chartWrap = document.getElementById('chartWrap');
  if (cards) cards.innerHTML = '';
  if (totals) totals.innerHTML = '';
  if (resultCount) resultCount.textContent = '0 itens';
  if (chartWrap) chartWrap.classList.remove('visible');
  if (window.pieChart){ try{ window.pieChart.destroy(); }catch{} window.pieChart = null; }
}

function swapExportBtn(forRay){
  const btnNow = document.getElementById('exportConferencia'); // busca SEMPRE o atual no DOM
  if (!btnNow) return;
  const clone = btnNow.cloneNode(true);
  clone.id = 'exportConferencia';

  if (forRay){
    clone.textContent = 'Exportar CSV RAY (Unificado)';
    clone.dataset.mode = 'analysis';
    clone.disabled = !__RAY_READY;
    clone.addEventListener('click', (e)=>{
      e.preventDefault(); e.stopPropagation();
      if (rayExp) rayExp.click(); else alert('Exportação RAY indisponível.');
    });
  }else{
    clone.textContent = 'Relatório de Conferência';
    clone.dataset.mode = 'home';
    clone.disabled = false;
    // reanexa o handler padrão da HOME, sem alterar a HOME
    clone.addEventListener('click', (e)=>{
      e.preventDefault(); e.stopPropagation();
      const rows = (typeof getFiltered === 'function') ? getFiltered() : [];
      if (!rows || !rows.length) { alert('Nada para exportar.'); return; }
      if (typeof exportConferencia === 'function') exportConferencia(rows);
    });
  }
  btnNow.replaceWith(clone);
}

function modeHome(){
  __MODE = 'home';
  if (fileLbl) fileLbl.classList.remove('hidden');
  if (raySideBtn) raySideBtn.classList.add('hidden');
  swapExportBtn(false);
  hideOverlay();
  clearPreviewUI();
  ensureUnitFilterUI(); toggleUnitFilterUI(); // construção só após importação do RAY
}

function modeAnal(){
  __MODE = 'analysis';
  if (fileLbl) fileLbl.classList.add('hidden');
  if (raySideBtn) raySideBtn.classList.remove('hidden');
  swapExportBtn(true);
  ensureUnitFilterUI(); toggleUnitFilterUI(); // mostra na Análise
}

if (snHome) snHome.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); modeHome(); }, true);
if (snAnal) snAnal.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); modeAnal(); }, true);

/* Botões do overlay */
if (overlayShowBtn){
  window.triggerAnalysisPreview = async function(){ // usado também ao trocar “unidade”
    if (!__RAY_READY || !__RAY_DATA) return;
    try{
      const { startDateStr, endDateStr, conversations } = __RAY_DATA;
      const sd = new Date(`${startDateStr}T00:00:00-03:00`).getTime();
      const ed = new Date(`${endDateStr}T23:59:59-03:00`).getTime();

      const filtered = (conversations||[]).map(conv=>{
        const uid = String(conv.user_id || '');
        // aplica filtro por unidade de negócio (se selecionado)
        if (UNIT_FILTER && CLIENTS_INFO){
          const code = normCode(parseUserId(uid).cliente);
          const info = CLIENTS_INFO.get(code) || CLIENTS_INFO.get(normCode(code));
          if (!info || info.unidade !== UNIT_FILTER) return null;
        }
        const msgs = Array.isArray(conv.messages) ? conv.messages : [];
        const kept = [];
        for (let i=0;i<msgs.length;i++){
          const m = msgs[i]; const role = (m?.role||'').toLowerCase();
          if (role !== 'user') continue;
          const t = new Date(m.createdAt || m.timestamp || 0).getTime() - 3*60*60*1000;
          if (isNaN(t) || t < sd || t > ed) continue;
          let ok = false;
          for (let j=i+1;j<msgs.length;j++){
            const a = msgs[j]; const r = (a?.role||'').toLowerCase();
            if (r === 'user') break;
            if (r === 'assistant'){
              if (a && (a.score != null || (a.content && /"score"\s*:/i.test(JSON.stringify(a.content))))) ok = true;
              break;
            }
          }
          if (ok){ kept.push(m); kept.push(msgs[i+1]); }
        }
        if (!kept.length) return null;
        return Object.assign({}, conv, { messages: kept });
      }).filter(Boolean);

      const parsed = parseJson({ conversations: filtered }) || [];
      __RAY_ROWS = parsed;
    }catch(err){
      console.error('Erro ao preparar preview RAY:', err);
      __RAY_ROWS = [];
    }
    clearPreviewUI();
    window.DATA = __RAY_ROWS;
    hideOverlay();
    render();
  };
  overlayShowBtn.addEventListener('click', ()=>{ window.triggerAnalysisPreview(); });
}
// exportação “separada” reaproveitando o handler do botão oculto (um clique por arquivo)
async function exportRaySeparate(){
  if (!Array.isArray(__RAY_FILES) || !__RAY_FILES.length){ alert('Importe arquivos RAY primeiro.'); return; }
  const original = __RAY_DATA;
  const originalName = (typeof __RAY_FILE_NAME_OVERRIDE === 'string') ? __RAY_FILE_NAME_OVERRIDE : '';

  for (const item of __RAY_FILES){
    __RAY_DATA = item.data; // contexto do exportador (cada JSON)
    const bot = String(item?.data?.chatbotName || '').trim();
    const s = String(item?.data?.startDateStr || '').trim();
    const e = String(item?.data?.endDateStr || '').trim();

    const sanitize = (t)=> String(t||'')
      .normalize('NFD').replace(/[\u0300-\u036f]/g,'') // remove diacríticos
      .replace(/[^\p{L}\p{N}]+/gu,'_')                 // mantém letras/números, troca separadores por "_"
      .replace(/^_+|_+$/g,'');                         // trim de "_"

    const base = sanitize(bot) || sanitize((item.name||'').replace(/\.json$/i,''));
    const fname = `${base}_${sanitize(s)}_a_${sanitize(e)}.csv`;

    if (typeof window.__RAY_FILE_NAME_OVERRIDE === 'string') window.__RAY_FILE_NAME_OVERRIDE = fname;

    if (rayExp){
      rayExp.click();                      // dispara export do arquivo atual
      await new Promise(r=>setTimeout(r)); // serializa (entrega o contexto antes de trocar)
    }
  }

  __RAY_DATA = original; // restaura unificado
  if (typeof __RAY_FILE_NAME_OVERRIDE === 'string') __RAY_FILE_NAME_OVERRIDE = originalName;
}

// Overlay
if (overlayExportUniBtn){
  overlayExportUniBtn.addEventListener('click', ()=>{ if (rayExp) rayExp.click(); });
}
if (overlayExportSepBtn){
  overlayExportSepBtn.addEventListener('click', exportRaySeparate);
}
if (overlayExportDetBtn){
  overlayExportDetBtn.addEventListener('click', exportRayDetailed);
}

// Mesmos handlers na aba Análise
if (rayExpUniBtn){
  rayExpUniBtn.addEventListener('click', ()=>{ if (rayExp) rayExp.click(); });
}
if (rayExpSepBtn){
  rayExpSepBtn.addEventListener('click', exportRaySeparate);
}
if (rayExpDetBtn){
  rayExpDetBtn.addEventListener('click', exportRayDetailed);
}

// === Relatório de Uso detalhado (CSV, sem agrupamento)
async function exportRayDetailed(){
  try{
    if (!window.__RAY_READY || (!window.__RAY_DATA && (!Array.isArray(window.__RAY_FILES) || !window.__RAY_FILES.length))){
      alert('Importe arquivo(s) RAY primeiro.');
      return;
    }

    const nameMap = (typeof loadClientMap === 'function') ? await loadClientMap() : new Map();
    const INTERNAL = (typeof INTERNAL_LICENSE_CODES !== 'undefined') ? INTERNAL_LICENSE_CODES : new Set();
    const files = (Array.isArray(window.__RAY_FILES) && window.__RAY_FILES.length)
      ? window.__RAY_FILES
      : [{ data: window.__RAY_DATA }];

    // Cabeçalho exatamente como solicitado
    const header = [
      'Codigo do Cliente',
      'Nome do Cliente',
      'Data (dd/mm/aaaa — horário local UTC−3)',
      'Hora (hh:mm — horário local UTC−3)',
      'Sistema'
    ];
    const allRows = [header];

    const p2 = (typeof pad2 === 'function') ? pad2 : (n => String(n).padStart(2,'0'));

    for (const item of files){
      const data = item && item.data ? item.data : {};
      const bot  = String(data.chatbotName || '').trim();
      const sStr = String(data.startDateStr || '').trim();
      const eStr = String(data.endDateStr  || '').trim();
      const convs= Array.isArray(data.conversations) ? data.conversations : [];
      if (!sStr || !eStr || !convs.length) continue;

      // intervalo local UTC−3
      const sd = new Date(`${sStr}T00:00:00-03:00`).getTime();
      const ed = new Date(`${eStr}T23:59:59-03:00`).getTime();

      for (const conv of convs){
        const uid = String(conv?.user_id || conv?.anonymous_id || '');

        // filtro por UNIDADE (mesma regra dos outros relatórios)
        if (typeof UNIT_FILTER !== 'undefined' && UNIT_FILTER && typeof CLIENTS_INFO !== 'undefined' && CLIENTS_INFO){
          const rawCli  = (parseUserId(uid).cliente || '');
          const codeNorm= normCode(rawCli);
          const info = CLIENTS_INFO.get(rawCli) || CLIENTS_INFO.get(codeNorm);
          if (!info || info.unidade !== UNIT_FILTER) continue;
        }

        const msgs = Array.isArray(conv?.messages) ? conv.messages : [];
        for (let i=0; i<msgs.length; i++){
          const m = msgs[i]; const role = String(m?.role||'').toLowerCase();
          if (role !== 'user' || !m.createdAt) continue;

          // createdAt no local (UTC−3)
          const tLocal = new Date(m.createdAt || m.timestamp || 0).getTime() - 3*60*60*1000;
          if (isNaN(tLocal) || tLocal < sd || tLocal > ed) continue;

          // precisa do assistant IMEDIATO com "score"
          let ok = false;
          for (let j=i+1; j<msgs.length; j++){
            const a = msgs[j]; const r = String(a?.role||'').toLowerCase();
            if (r === 'user') break;
            if (r === 'assistant'){
              if (a && (a.score != null || (a.content && /"score"\s*:/i.test(JSON.stringify(a.content))))) ok = true;
              break;
            }
          }
          if (!ok) continue;

          // Código + Nome (com normalização e “Licença Interna”)
          const rawCode = (parseUserId(uid).cliente || '');
          const code    = normCode(rawCode);
          let name = '';
          if (rawCode || code){
            name = nameMap.get(rawCode) || nameMap.get(code) || '';
            if (code && INTERNAL.has(code)) name = 'Licença Interna';
          }else{
            name = 'Cliente não identificado';
          }

          // Data/Hora formatadas a partir do horário local (UTC−3)
          const d = new Date(tLocal);
          const datePt = `${p2(d.getUTCDate())}/${p2(d.getUTCMonth()+1)}/${d.getUTCFullYear()}`;
          const timePt = `${p2(d.getUTCHours())}:${p2(d.getUTCMinutes())}`;

          allRows.push([code, name, datePt, timePt, bot]);
        }
      }
    }

    if (allRows.length === 1){
      alert('Nenhuma interação válida no período/filtros.');
      return;
    }

    // CSV com ; e BOM, como os demais
    const csv = '\uFEFF' + allRows.map(r => r.map(v => {
      const s = String(v ?? '');
      return /[;"\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
    }).join(';')).join('\n');

    const fname = `relatorio_uso_detalhado_${fmtYMD(new Date())}.csv`;
    if (typeof download === 'function'){ download(fname, csv); }
    else {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(new Blob([csv], {type:'text/csv;charset=utf-8'}));
      a.download = fname; a.click(); URL.revokeObjectURL(a.href);
    }
  }catch(err){
    console.error('Erro ao exportar Relatório de Uso detalhado:', err);
    alert('Ocorreu um erro ao gerar o Relatório de Uso detalhado.');
  }
}

/* Botões de importação da Análise */
if (rayBtn && rayInp && !rayBtn.dataset.rayBound){
  rayBtn.dataset.rayBound = '1';
  rayBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); rayInp.click(); });
}
if (raySideBtn && rayInp && !raySideBtn.dataset.rayBound){
  raySideBtn.dataset.rayBound = '1';
  // botão lateral da Análise também abre o input real da aba Análise
  raySideBtn.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); rayInp.click(); });
}

/* ======== Importação do JSON RAY (parse + nomes) ======== */
if (rayInp){
  rayInp.addEventListener('change', async ()=>{
    const files = Array.from(rayInp.files || []);
    __RAY_DATA = null; __RAY_ROWS = []; __RAY_READY = false;
window.__RAY_DATA = null; window.__RAY_FILES = []; window.__RAY_READY = false;

    // feedback visual dos arquivos selecionados
    (function(){
      const nameEl = document.getElementById('rayFileName');
      if (!nameEl) return;
      if (!files.length) nameEl.textContent = 'Nenhum arquivo selecionado';
      else if (files.length === 1) nameEl.textContent = files[0].name;
      else nameEl.textContent = `${files.length} arquivos selecionados`;
    })();

    if (!files.length){ hideOverlay(); swapExportBtn(true); return; }
    showOverlayLoading();

    try{
      let startMin = null, endMax = null;
      const convs = [];
      const perFiles = [];

      for (const f of files){
        const txt = await f.text();
        const json = JSON.parse(txt);

        // validações mínimas por arquivo
        const ok = json && json.startDateStr && json.endDateStr && (Array.isArray(json.conversations) || json.messages);
        if (!ok) throw new Error(`JSON RAY fora do padrão esperado (${f.name}).`);

        const s = String(json.startDateStr).trim();
        const e = String(json.endDateStr).trim();
        if (!startMin || s < startMin) startMin = s;
        if (!endMax   || e > endMax)   endMax   = e;

        // normaliza como “conversations[]” tanto para arquivos já normalizados quanto p/ raiz messages
        const convsThis = Array.isArray(json.conversations) ? json.conversations.slice()
                         : (json.messages ? [json] : []);
        convs.push(...convsThis);

        // guarda entrada individual (nome + data normalizado) p/ exportação “separada”
perFiles.push({ name: f.name, data: { chatbotName: String(json.chatbotName||'').trim(), startDateStr: s, endDateStr: e, conversations: convsThis } });      }

      // dataset unificado (mantido)
      __RAY_DATA = { startDateStr: startMin || '', endDateStr: endMax || '', conversations: convs };
      window.__RAY_DATA = __RAY_DATA;
      __RAY_FILES = perFiles;
      window.__RAY_FILES = __RAY_FILES;

      __RAY_ROWS = parseJson(__RAY_DATA);
      if (typeof loadClientMap === 'function'){ await loadClientMap(); }
      if (typeof populateClientNames === 'function'){ await populateClientNames(); }

      __RAY_READY = true;
      window.__RAY_READY = true;
      showOverlayReady();
      swapExportBtn(true);
      ensureUnitFilterUI(); toggleUnitFilterUI(); refreshUnitFilterOptions();
      if (rayExp) rayExp.disabled = false;

    }catch(err){
      console.error('Falha ao ler Arquivo(s) RAY:', err);
      alert('Arquivo RAY inválido. Selecione JSON(s) válidos.');
      hideOverlay();
      __RAY_READY = false;
      swapExportBtn(true);
    }
  });
}

/* ======== Exportação CSV RAY (UTC−3 e período start/end) ======== */
if (rayExp){
  rayExp.addEventListener('click', async ()=>{
    if (!__RAY_DATA){ alert('Importe um arquivo RAY primeiro.'); return; }

    const startDateStr = String(__RAY_DATA.startDateStr||'').trim();
    const endDateStr   = String(__RAY_DATA.endDateStr||'').trim();

    // Limites no fuso −03:00 (IMPORTAÇÃO SEMPRE PERMITIDA; FILTRAGEM SÓ NO CSV)
    const sd = new Date(`${startDateStr}T00:00:00-03:00`).getTime();
    const ed = new Date(`${endDateStr}T23:59:59-03:00`).getTime();

    // Mapa nomes/unidades
    const map = (typeof loadClientMap==='function') ? await loadClientMap() : null;
    const INTERNAL = (typeof INTERNAL_LICENSE_CODES!=='undefined' && INTERNAL_LICENSE_CODES) ? INTERNAL_LICENSE_CODES : new Set();

    // === Regra oficial de interação (mantida) ===
    // Contar SOMENTE quando existir par (user -> assistant IMEDIATO) e o assistant tiver "score".
    // Também só vale se createdAt(user) -3h ∈ [sd..ed].
    const counts       = new Map(); // key -> qtd de interações (par user→assistant com score)
    const customClicks = new Map(); // key -> qtd de cliques em botão customizado
    const firstTime    = new Map(); // key -> ms(-3h)
    const lastTime     = new Map(); // key -> ms(-3h)

    // Distintos por tipo
    const identifiedCodes   = new Set(); // códigos reais
    const unidentifiedCodes = new Set(); // chaves sintéticas p/ NI

    // Chaves para "não identificado"
    const UNID_PREFIX = '__NI__';
    let niSeq = 1; // contador local p/ rotular NI quando não existir id da conversa

    const convs = (__RAY_DATA.conversations || []).filter(Boolean);
    for (const conv of convs){
      const uidConv  = String(conv.user_id || '');
      const codeConv = normCode((parseUserId(uidConv).cliente || '').trim());

      // Filtro por unidade de negócio, se ativo (não há unidade para NI)
      if (UNIT_FILTER && CLIENTS_INFO){
        const info = CLIENTS_INFO.get(codeConv) || CLIENTS_INFO.get(normCode(codeConv));
        if (!info || info.unidade !== UNIT_FILTER) continue;
      }

      // Define a chave de agrupamento:
      // - Identificados: o próprio código
      // - Não identificados: chave sintética estável por conversa (id/uuid) ou sequencial
      let keyBase = codeConv;
      if (!keyBase){
        const convId = String(conv.id || conv.conversation_id || conv.uuid || conv.sessionId || '');
        keyBase = UNID_PREFIX + (convId || String(niSeq++));
      }

      const arr = Array.isArray(conv.messages) ? conv.messages : [];
      for (let i = 0; i < arr.length; i++){
        const mUser = arr[i];
        if ((mUser.role||'').toLowerCase() !== 'user') continue;

        const tUser = new Date(mUser.createdAt || mUser.timestamp || 0).getTime() - 3*60*60*1000;
        if (isNaN(tUser) || tUser < sd || tUser > ed) continue;

        // Varre até o próximo 'user' para (a) detectar botão customizado e (b) achar o assistant imediato
        let next = null;
        let hadCustom = false;
        for (let j = i+1; j < arr.length; j++){
          const a = arr[j]; const r = (a?.role||'').toLowerCase();
          if (r === 'user') break; // fim da janela desta interação
          if (r === 'tool' && String(a.actionType||'').toLowerCase() === 'custom-button'){ hadCustom = true; }
          if (r === 'assistant'){ next = a; break; }
        }
        // Conta clique em botão customizado (não soma em 'Interacoes' para evitar dupla contagem)
        if (hadCustom){
          customClicks.set(keyBase, (customClicks.get(keyBase)||0) + 1);
        }
        if (!next) continue;

        const hasScore =
          (next.score != null) ||
          (next.evaluation && next.evaluation.score != null) ||
          (typeof next.content === 'string' && /\"score\"\s*:/.test(next.content));
        if (!hasScore) continue;

        const codeKey = keyBase;
        counts.set(codeKey, (counts.get(codeKey)||0) + 1);

        if (!firstTime.has(codeKey) || tUser < firstTime.get(codeKey)) firstTime.set(codeKey, tUser);
        if (!lastTime.has(codeKey)  || tUser > lastTime.get(codeKey))  lastTime.set(codeKey,  tUser);

        // marca tipo do cliente para totalizadores
        if (String(codeKey).startsWith(UNID_PREFIX)) {
          unidentifiedCodes.add(codeKey);
        } else {
          identifiedCodes.add(codeKey);
        }
      }
    }

    // Cabeçalho e dados (substitui “CLIENTES DISTINTOS” por dois totalizadores)
    const dateLabel = (startDateStr === endDateStr) ? startDateStr : (startDateStr + ' – ' + endDateStr);
    const rows = [[
      'Codigo',
      'Cliente',
      'Unidade de Negócio',
      'Interacoes',
      'Cliques Botão Customizado',
      'Data',
      'Hora Primeira Interação',
      'Hora da Última Interação',
      'Clientes Distintos Identificados',
      'Clientes Não Identificados'
    ]];


    const hhmmss = (ms) => {
      const d = new Date(ms);
      const hh = String(d.getUTCHours()).padStart(2,'0');
      const mm = String(d.getUTCMinutes()).padStart(2,'0');
      const ss = String(d.getUTCSeconds()).padStart(2,'0');
      return `${hh}:${mm}:${ss}`;
    };

    // Geração das linhas — mantém ordenação por chave
    let first = true;
    Array.from(counts.entries())
      .sort(([a],[b]) => String(a).localeCompare(String(b),'pt-BR'))
      .forEach(([codeKey, qty])=>{
        const isNI = String(codeKey).startsWith(UNID_PREFIX);

        // Info para identificados
        const info = (!isNI && CLIENTS_INFO) ? (CLIENTS_INFO.get(codeKey) || CLIENTS_INFO.get(normCode(codeKey))) : null;
        const unit = info?.unidade ? String(info.unidade) : '';

        // Nome
        let name;
        if (isNI){
          // tenta extrair número da chave; senão numera pela ordem
          const suffix = String(codeKey).slice(UNID_PREFIX.length);
          const n = (/^\d+$/.test(suffix)) ? Number(suffix) : (Array.from(unidentifiedCodes).indexOf(codeKey) + 1);
          name = `Cliente não identificado ${n}`;
        } else {
          name = info?.name || (map ? (map.get(codeKey) || map.get(normCode(codeKey)) || '') : '');
          if (codeKey && INTERNAL.has(codeKey)) name = 'Licença Interna';
        }

        const f = firstTime.get(codeKey);
        const l = lastTime.get(codeKey);

        rows.push([
          isNI ? '' : codeKey,    // Código em branco para NI
          name,
          unit,
          String(qty),
          String(customClicks.get(codeKey) || 0),
          dateLabel,
          f != null ? hhmmss(f) : '',
          l != null ? hhmmss(l) : '',
          first ? String(identifiedCodes.size)   : '',
          first ? String(unidentifiedCodes.size) : ''
        ]);
        first = false;
      });

    if (rows.length === 1){ alert('Nenhuma interação válida no período/filtros.'); return; }

    const csv = rows.map(r => r.map(v => (String(v||'').includes(';') ? `"${String(v).replace(/"/g,'""')}"` : String(v))).join(';')).join('\n');
    const fname = `ray_export_${startDateStr.replace(/-/g,'')}_${endDateStr.replace(/-/g,'')}.csv`;
    download(fname, csv);
  });
}


/* --- Integração Google Sheets (código → nome do cliente) --- */
/* Preencha via variáveis globais (opcional) antes deste arquivo:
   window.GOOGLE_SHEET_ID = '...';
   window.GOOGLE_API_KEY  = '...';
   window.GOOGLE_SHEET_RANGE = 'Clientes!A:C';
*/
let CLIENTS_MAP = null; // cache Map<código, nome>
const GOOGLE_SHEET_ID   = window.GOOGLE_SHEET_ID   || '1JyckmObUPWGXy1-0jvBYWbPfQg6Owf6xjgG1Z2vWdZw';
const GOOGLE_API_KEY    = window.GOOGLE_API_KEY    || '';
const GOOGLE_SHEET_RANGE= window.GOOGLE_SHEET_RANGE|| 'Clientes!A:C'; // inclui unidade

// Mapa estendido: code|norm -> { name, unidade }
if (!CLIENTS_INFO) CLIENTS_INFO = new Map();

// Códigos especiais que devem aparecer como "Licença Interna" (preencha até 10)
const INTERNAL_LICENSE_CODES = new Set([
  /* 1 */ '',
  /* 2 */ '',
  /* 3 */ '',
  /* 4 */ '',
  /* 5 */ '',
  /* 6 */ '',
  /* 7 */ '',
  /* 8 */ '',
  /* 9 */ '',
  /* 10 */ ''
]);

/* ===================== Utilidades ===================== */
const $  = sel => document.querySelector(sel);
const $$ = sel => Array.from(document.querySelectorAll(sel));
function download(filename, text){
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([text], {type: 'text/plain;charset=utf-8'}));
  a.download = filename; a.click(); URL.revokeObjectURL(a.href);
}
function stripEmoji(str){ return (str||"").replace(/[\p{Emoji_Presentation}\p{Emoji}\uFE0F]/gu, '').trim(); }
function denoise(s){ return (s||"").normalize('NFD').replace(/[\u0300-\u036f]/g,''); }
function escapeHtml(s){
  return (s||'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m]));
}
function normCode(s){
  const t = String(s||'').trim();
  return t.replace(/^0+/, ''); // remove zeros à esquerda para comparação/agrupamento
}

/* Parse de user_id: "12345.abc" → {cliente:"12345", usuario:"abc"} */
function parseUserId(uid){
  const m = String(uid||'').trim().match(/^(\d+)\.(.+)$/);
  return m ? { cliente: m[1], usuario: m[2] } : { cliente: '', usuario: '' };
}

/* HTML para exibir a identificação; nome do cliente é preenchido depois */
function userIdHTML(uid){
  const {cliente, usuario} = parseUserId(uid);

  // Códigos que devem ter destaque vermelho
  const RED_ALERT = new Set(['000001','107030','817809','676364','820365','820362','820267','820268','820363','820364','820366']);

  // Sem user_id → exibe "Cliente não identificado" (também na preview)
  if (!cliente){
    return `<div class="client-id" data-client-code="">
              <span class="small-label">Cliente:</span>
              <span class="client-code">Cliente não identificado</span>
            </div>`;
  }

const usuarioTxt = usuario ? ` / Usuário: ${escapeHtml(usuario)}` : '';
  const isAlert = RED_ALERT.has(cliente) || RED_ALERT.has(normCode(cliente));
  const style   = isAlert ? ' style="color:#ff6b6b; font-weight:900"' : '';

  /* client-name será preenchido pelo populateClientNames() */
  return `<div class="client-id" data-client-code="${escapeHtml(cliente)}">
            <span class="small-label">Cliente:</span>
            <span class="client-code"${style}>${escapeHtml(cliente)}</span>
            <span class="client-name"></span>${usuarioTxt}
          </div>`;
}

/* Carrega a planilha (A:C → código, nome, unidadeNegocio) com cache in-memory.
   1) Tenta Apps Script (window.CLIENTS_API_URL).
   2) Se não vier unidade ou falhar, faz fallback direto via Google Sheets API (GOOGLE_SHEET_ID/GOOGLE_API_KEY). */
async function loadClientMap(){
  if (CLIENTS_MAP && CLIENTS_INFO && CLIENTS_INFO.size) return CLIENTS_MAP;
  CLIENTS_MAP = new Map();
  if (!CLIENTS_INFO) CLIENTS_INFO = new Map();

  const fill = (code, name, unidade)=>{
    const c = String(code||'').trim(); if (!c) return;
    const n = String(name||'').trim();
    const u = String(unidade||'').trim();
    const nc = normCode(c);

    if (!CLIENTS_MAP.has(c))  CLIENTS_MAP.set(c, n);
    if (!CLIENTS_MAP.has(nc)) CLIENTS_MAP.set(nc, n);

    const info = { name: n, unidade: u };
    if (!CLIENTS_INFO.has(c))  CLIENTS_INFO.set(c, info);
    if (!CLIENTS_INFO.has(nc)) CLIENTS_INFO.set(nc, info);
  };

  // 1) Tentativa via Apps Script
  try{
    const url = (window.CLIENTS_API_URL ||
      'https://script.google.com/macros/s/AKfycbxh_ZNXtxtE7W5UUCqX1mCcecpzGM3AEDzVaCxuhEiLVh10sf2wh7n-2lYAc8GwBjz7/exec');
    const resp = await fetch(url, { headers: { 'Accept':'application/json' }});
    if (!resp.ok) throw new Error('HTTP '+resp.status);
    const json = await resp.json();
    const list = (json && Array.isArray(json.clientes)) ? json.clientes : [];
    for (const it of list){ fill(it.codigo, it.nome, it.unidadeNegocio); }
  }catch(err){
    console.warn('Falha ao carregar clientes (Apps Script):', err);
  }

  // 2) Fallback direto na planilha, caso não haja unidades
  try{
const needUnits = CLIENTS_INFO.size === 0 || Array.from(CLIENTS_INFO.values()).some(v => !v || !v.unidade);
    if (needUnits && GOOGLE_SHEET_ID && GOOGLE_API_KEY){
      const url2 = `https://sheets.googleapis.com/v4/spreadsheets/${encodeURIComponent(GOOGLE_SHEET_ID)}/values/${encodeURIComponent(GOOGLE_SHEET_RANGE)}?key=${encodeURIComponent(GOOGLE_API_KEY)}`;
      const r2 = await fetch(url2, { headers: { 'Accept':'application/json' }});
      if (r2.ok){
        const j2 = await r2.json();
        const vals = Array.isArray(j2?.values) ? j2.values : [];
        if (vals.length){
          // aceita variações de cabeçalho: CodigoCliente/NomeCliente/unidadeNegocio
          const headerRaw = vals[0].map(h => String(h||'').trim());
          const header = headerRaw.map(h => h.toLowerCase());

          const findIdx = (names) => {
            for (const n of names) {
              const i = header.indexOf(String(n).toLowerCase());
              if (i !== -1) return i;
            }
            return -1;
          };

          // A: código, B: nome, C: unidade (fallback p/ posição se não achar pelo nome)
          let iCode = findIdx(['codigo','codigocliente','código','codigo cliente','id']);
          let iName = findIdx(['nome','nomecliente','nome cliente','razao social','razão social']);
          let iUnit = findIdx(['unidadenegocio','unidade negocio','unidade de negocio','unidade','unidade_negocio','unidade-negocio']);

          if (iCode === -1) iCode = 0;
          if (iName === -1) iName = 1;
          if (iUnit === -1) iUnit = 2;

          for (let i=1; i<vals.length; i++){
            const row = vals[i] || [];
            fill(row[iCode] ?? '', row[iName] ?? '', row[iUnit] ?? '');
          }
        }
      }
    }
  }catch(err){
    console.warn('Falha ao carregar clientes (Sheets API):', err);
  }

  return CLIENTS_MAP;
}

/* Preenche os nomes de cliente nos cards já renderizados (nome + “ · Unidade: …”) */
async function populateClientNames(){
  const map = await loadClientMap();
  document.querySelectorAll('.client-id[data-client-code]').forEach(el=>{
    const raw = el.getAttribute('data-client-code') || '';
    const code = normCode(raw);
    let name = map.get(raw) || map.get(code) || '';
    if (code && INTERNAL_LICENSE_CODES && INTERNAL_LICENSE_CODES.has(code)) {
      name = 'Licença Interna';
    }

    const nameEl = el.querySelector('.client-name');
    if (nameEl && name && !nameEl.dataset.filled){
      nameEl.textContent = ` - ${name}`;
      nameEl.dataset.filled = '1';
    }

    // Unidade com rótulo, criando o span se não existir
let unitEl = el.querySelector('.client-unit');
if (!unitEl){
  unitEl = document.createElement('span');
  unitEl.className = 'client-unit';
  // insere ao final do bloco para ficar após " / Usuário"
  el.appendChild(unitEl);
}
if (unitEl && !unitEl.dataset.filled){
  const info = CLIENTS_INFO ? (CLIENTS_INFO.get(raw) || CLIENTS_INFO.get(code)) : null;
  const unit = info && info.unidade ? String(info.unidade).trim() : '';
  unitEl.textContent = unit ? ` / Unidade de Negócio: ${unit}` : '';
  unitEl.dataset.filled = '1';
}
  });
}

/* realça o termo da busca no HTML já “escapado” */
function highlight(escapedHtml, term){
  const q = (term||"").trim();
  if (!q) return escapedHtml;
  try{
    const esc = q.replace(/[.*+?^${}()|[\]\\]/g,'\\$&');
    const re  = new RegExp(esc, 'gi');
    return escapedHtml.replace(re, m => `<mark>${m}</mark>`);
  }catch{ return escapedHtml; }
}

/* NORMALIZAÇÃO de classificação (mantém compat com históricos) */
function normalizeClassName(s){
  const raw   = (s||'').trim();
  const lower = denoise(stripEmoji(raw)).toLowerCase();

  if (raw.includes('✅')) return 'Correta';
  if (raw.includes('❌') || raw.includes('✖') || /\b[xX]\b/.test(raw)) return 'Incorreta';
  if (raw.includes('⚠️') || raw.includes('⚠')) return 'Falta de Documentação';
  if (raw.includes('🔎')) return 'Pergunta investigativa';

  if (/\bcorret[ao]?\b/.test(lower)) return 'Correta';
  if (/\bincorret[ao]?\b|\berrad[oa]\b|\bnao atende\b|\bnão atende\b|\binadequad[oa]\b|\bimprocedent[ea]\b|\bincabivel\b|\bincabível\b/.test(lower)) return 'Incorreta';
  if (lower.includes('falta') && (lower.includes('document') || lower.includes('doc'))) return 'Falta de Documentação';
  if (/\binvestigativ[ao]?\b/.test(lower)) return 'Pergunta investigativa';

  return 'Sem classificação';
}
function withEmoji(cls){
  switch(cls){
    case 'Correta': return '✅ Correta';
    case 'Incorreta': return '❌ Incorreta';
    case 'Falta de Documentação': return '⚠️ Falta de Documentação';
    case 'Pergunta investigativa': return '🔎 Pergunta investigativa';
    case 'Sem classificação': return '⭕ Sem classificação';
    default: return cls;
  }
}
function colorDotFor(cls){
  if (cls==='Correta') return 'ok';
  if (cls==='Incorreta') return 'err';
  if (cls==='Falta de Documentação') return 'warn';
  if (cls==='Pergunta investigativa') return 'inv';
  return 'other';
}
function chipClassFor(cls){
  if (cls==='Correta') return 'cls-ok';
  if (cls==='Incorreta') return 'cls-err';
  if (cls==='Falta de Documentação') return 'cls-warn';
  if (cls==='Pergunta investigativa') return 'cls-inv';
  return 'cls-other';
}
function classColor(cls){
  if (cls==='✅ Correta' || cls==='Correta') return '#55d88a';
  if (cls==='❌ Incorreta' || cls==='Incorreta') return '#ff6b6b';
  if (cls==='⚠️ Falta de Documentação' || cls==='Falta de Documentação') return '#f7c948';
  if (cls==='🔎 Pergunta investigativa' || cls==='Pergunta investigativa') return '#86b0ff';
  return '#a0a7b4';
}

/* Ordenação por código */
function codeParts(code){
  const m = (code||'').match(/^([A-Z]{2})(\d+)-(\d+)$/);
  if (!m) return {g: 9999, i: 9999};
  return { g: parseInt(m[2],10), i: parseInt(m[3],10) };
}
function groupLabelFromCode(code){ const {g} = codeParts(code); return 'GR'+String(g).padStart(2,'0'); }
function compareByGroup(a,b){
  const A = codeParts(a.codigo), B = codeParts(b.codigo);
  if (A.g !== B.g) return A.g - B.g;
  return A.i - B.i;
}

/* ===================== Parser ===================== */
/* … (idêntico ao anterior; suporta [INICIO_INTERACAO]/[FIM_INTERACAO] e legado) */
function splitByTagBlocks(text){
  const lines = (text || '').replace(/\r/g,'').split('\n');
  const blocks = []; let cur = null;
  for (let i=0;i<lines.length;i++){
    const raw = lines[i]; const line = raw.trim();
    if (/^\[INICIO_INTERACAO\]\s*$/i.test(line)){ if (cur){ blocks.push(cur); } cur = { code:'', text:'' }; continue; }
    if (/^\[FIM_INTERACAO\]\s*$/i.test(line)){ if (cur){ blocks.push(cur); cur = null; } continue; }
    if (cur){
      cur.text += raw + '\n';
      const m = line.match(/^(?:\[[^\]]+\]\s*)?Intera[çc][aã]o:\s*([A-Z]{2}\d+-\d+)/i);
if (m) cur.code = m[1].trim();
    }
  }
  if (cur){ blocks.push(cur); }
  return blocks.filter(b => b.text.trim().length > 0);
}
function splitByLegacyBlocks(text){
  const lines = (text || '').replace(/\r/g,'').split('\n');
  const blocks = []; let cur = null;
  for (let i=0;i<lines.length;i++){
    const raw = lines[i]; const line = raw.trim();
    const m = line.match(/^(?:\[[^\]]+\]\s*)?Intera[çc][aã]o:\s*([A-Z]{2}\d+-\d+)/i);
if (m){ if (cur) blocks.push(cur); cur = { code:m[1].trim(), text:'' }; continue; }
    if (cur){ cur.text += raw + '\n'; }
  }
  if (cur) blocks.push(cur);
  return blocks;
}
function splitAssistantBlocks(text){
  const byTags = splitByTagBlocks(text);
  if (byTags.length) return byTags;
  return splitByLegacyBlocks(text);
}
function matchField(text, re){
  const flags = re.flags?.replace?.('g','') || '';
  const rex = new RegExp('(?:\\[[^\\]]+\\]\\s*)?' + re.source, flags);
  const m = text.match(rex);
  return m ? (m[1] || '').trim() : '';
}
function matchBlock(text, startRe){
  const flags = startRe.flags?.replace?.('g','') || '';
  const start = new RegExp('(?:\\[[^\\]]+\\]\\s*)?' + startRe.source, flags);
  const idx = text.search(start);
  if (idx === -1) return '';
  const after = text.slice(idx).replace(start,'');
  const end = new RegExp(
    '\\n(?:\\s*(?:\\[[^\\]]+\\]\\s*)?(?:' +
      'Classifica[çc][aã]o:|' +
      'Justificativa\\s*\\(curta\\)\\s*:|' +
      'Documentos\\s+utilizados\\s*:|' +
      'Evid[eê]ncias\\s*\\(contagem\\)\\s*:|' +
      'Sugest[aã]o\\s+de\\s+melhoria\\s*:|' +
      'Pergunta\\s*:|' +
      'Resposta\\s*Kiara\\s*:|' +
      'Intera[çc][aã]o:' +
    ')|\\s*\\[FIM_INTERACAO\\]\\s*$)',
    'i'
  );
  const m = after.search(end);
  return (m === -1 ? after : after.slice(0, m)).trim();
}
function parseJson(json){
  const out = [];
  const convs = (json.conversations || [json]).filter(Boolean);

  for (const conv of convs){
    const messages = conv.messages || [];

    // Vamos coletar:
    // (a) TODAS as interações vindas de role:"user" (novo formato)
    // (b) As avaliações do role:"assistant" (para anexar por código)
    const interacoes = [];
    const evalByCode = new Map();     // codigo -> {classificacao, justificativa, docs, sugestao, ...}
    const detailsByCode = new Map();  // fallback visual (caso ainda venham Pergunta/Resposta nas TAGs)

    // 1) Varrer TODAS as mensagens
    for (const msg of messages){
      const role = (msg.role || '').toLowerCase();

      // 1a) Novo formato: user.content contém JSON com { grupo, interacoes:[{codigo, pergunta, resposta}] }
      if (role === 'user'){
        const txt = (msg.content || '').trim();

        // Tenta parse direto quando começa com "{"
        if (txt.startsWith('{')) {
          try{
            const obj = JSON.parse(txt);
            const grupo = obj.grupo || conv.id || '';
            if (Array.isArray(obj.interacoes)){
              for (const it of obj.interacoes){
                  interacoes.push({
                  grupo: grupo,
                  codigo: it.codigo || '',
                  pergunta: it.pergunta || '',
                  resposta: it.resposta || '',
                  user_id: it.user_id || ''
                });
              }
            }
          }catch(e){
            // Se não for JSON válido, ignoramos silenciosamente este bloco
          }
        } else {
          // (opcional) conteúdo não-JSON: ignorar
        }
      }

      // 1b) Avaliações no assistant (mantém compatibilidade e anexa por código)
      if (role === 'assistant'){
        // Só processa respostas de texto. tool-call / outros tipos não têm 'content' string.
        const type = String(msg.type || '').toLowerCase();
        const raw  = (typeof msg.content === 'string') ? msg.content : '';
        if (type && type !== 'text') { continue; }
        if (!raw) { continue; }

        const text = raw.replace(/\r/g,'');
        const blocks = splitAssistantBlocks(text); // sua função existente que quebra [INICIO_INTERACAO].[FIM_INTERACAO]

        for (const {code, text: body} of blocks){
          // garante o código
          let codeFinal = code;
          if (!codeFinal){
            const mCode = body.match(/^(?:\[[^\]]+\]\s*)?Intera[çc][aã]o:\s*([A-Z]{2}\d{2}-\d{2})/im);
            if (mCode) codeFinal = mCode[1].trim();
          }
          if (!codeFinal) continue;

          // captura campos de avaliação
          const clsLine      = matchField(body, /Classifica[çc][aã]o:\s*([^\n]+)/i);
          const clsNorm      = normalizeClassName(clsLine);
          const justificativa= matchBlock(body, /Justificativa\s*\(curta\)\s*:\s*/i);
          const docs         = matchBlock(body, /Documentos\s+utilizados\s*:\s*/i);
          const sugestao     = matchBlock(body, /Sugest[aã]o\s+de\s+melhoria\s*:\s*/i);

          // Metadados adicionais do RAY: [Data], [Hora], [Topicos]
          // Exemplo de linhas:
          // [Data]: 05/12/2025
          // [Hora]: 07:07:45
          // [Topicos]: Erro ao acessar o sistema NG
          const mData = body.match(/^\s*\[Data\]\s*:\s*([^\n]+)/im);
          const mHora = body.match(/^\s*\[Hora\]\s*:\s*([^\n]+)/im);
          const mTop  = body.match(/^\s*\[Topicos?\]\s*:\s*([^\n]*)/im);

          const dataStr    = mData ? mData[1].trim() : '';
          const horaStr    = mHora ? mHora[1].trim() : '';
          const topicosStr = mTop  ? mTop[1].trim()  : '';

          // Array opcional de tópicos para usos futuros/filtro
          const topicsArr = topicosStr
            ? topicosStr.split(/[;|]/).map(s => s.trim()).filter(Boolean)
            : [];

          evalByCode.set(codeFinal, {
            classificacao: clsNorm,
            classificacaoEmoji: clsLine && clsLine.trim(),
            justificativa: justificativa || '',
            docs: docs || '',
            sugestao: sugestao || '',
            // novos campos
            data: dataStr,
            hora: horaStr,
            topicos: topicosStr,
            topics: topicsArr
          });


          // Fallback (LEGADO): se ainda vierem Pergunta/Resposta nas TAGs do assistant
          const perguntaTxt = matchBlock(body, /Pergunta\s*:\s*/i);
          const respostaTxt = matchBlock(body, /Resposta\s*(?:Kiara)?\s*:\s*/i);
          if (perguntaTxt || respostaTxt){
            detailsByCode.set(codeFinal, {
              pergunta: (perguntaTxt || '').trim(),
              resposta: (respostaTxt || '').trim()
            });
          }
        }
      }
    } // fim do for messages

    // 2) Fallback: se NENHUMA interação veio do user, tenta montar a partir das TAGs antigas do assistant
    if (!interacoes.length && detailsByCode.size){
      for (const code of detailsByCode.keys()){
        const det = detailsByCode.get(code) || {};
        interacoes.push({
          grupo: groupLabelFromCode(code),
          codigo: code,
          pergunta: det.pergunta || '',
          resposta: det.resposta || ''
        });
      }
    }

          // 3) Monta as linhas finais combinando Interações + Avaliações
      for (const it of interacoes){
        if (!it.codigo) continue; // ignora itens sem código
        const ev = evalByCode.get(it.codigo) || {classificacao:'Sem classificação', classificacaoEmoji:'⭕ Sem classificação'};

            out.push({
        grupo: it.grupo || conv.id || '',
        codigo: it.codigo,
        pergunta: it.pergunta,
        resposta: it.resposta,
        classificacao: ev.classificacao,
        classificacaoEmoji: ev.classificacaoEmoji || withEmoji(ev.classificacao),
        avaliacao: ev,
        user_id: it.user_id || '',
        // Metadados vindos do bloco de avaliação do assistant
        // (usados pelo render() e pelo filtro de tópicos)
        DATA: ev.data || '',
        HORA: ev.hora || '',
        TOPICOS: ev.topicos || '',
        topics: ev.topics || []
      });
    }
  } // fim do for convs

  // 4) Consolida por código (última ocorrência prevalece) e ordena por grupo/código
  const byCode = new Map();
  for (const row of out){
    byCode.set(row.codigo, {...(byCode.get(row.codigo)||{}), ...row});
  }
  return Array.from(byCode.values()).sort(compareByGroup);
}

/* ===================== Renderização ===================== */
function buildFilters(){
  const box = $('#filters'); box.innerHTML='';
  const list = ALL_CLASSES;
  for (const cls of list){
    const id = 'f_'+cls.replace(/\s+/g,'_');
    const row = document.createElement('label');
    row.className='filter-item';
    row.innerHTML = `<input type="checkbox" id="${id}"><span>${withEmoji(cls)}</span>`;
    box.appendChild(row);
    row.querySelector('input').addEventListener('change', (e)=>{
      if (e.target.checked) FILTERS.add(cls); else FILTERS.delete(cls);
      render();
    });
  }
}

/* Dropdown: só 3 opções; se a atual não está nas opções, mostra “— manter —” */
function classificationOptionsHTML(selected){
  const allowed = [
    {v:'Correta', t:'✅ Correta'},
    {v:'Incorreta', t:'❌ Incorreta'},
    {v:'Falta de Documentação', t:'⚠️ Falta de Documentação'}
  ];
  const isAllowed = allowed.some(a => a.v === selected);
  const head = isAllowed ? '' : `<option value="" selected disabled>— manter —</option>`;
  return head + allowed.map(o=>`<option value="${o.v}" ${o.v===selected?'selected':''}>${o.t}</option>`).join('');
}

function render(){
  const cards = $('#cards'); const totals = $('#totals'); const resultCount = $('#resultCount');
  cards.innerHTML = ''; totals.innerHTML = '';

  const textAll = (SEARCH || '').trim().toLowerCase();
const textQOnly = (SEARCH_Q || '').trim().toLowerCase();
const textAOnly = (SEARCH_A || '').trim().toLowerCase();

const passText = (it) => {
  // 1) Busca geral (onde quiser encontrar: código/pergunta/resposta)
  if (textAll) {
    const okAll =
      (it.pergunta || '').toLowerCase().includes(textAll) ||
      (it.resposta || '').toLowerCase().includes(textAll) ||
      (it.codigo   || '').toLowerCase().includes(textAll);
    if (!okAll) return false;
  }
  // 2) Filtro só em Pergunta (se preenchido)
  if (textQOnly) {
    if (!(it.pergunta || '').toLowerCase().includes(textQOnly)) return false;
  }
  // 3) Filtro só em Resposta (se preenchido)
  if (textAOnly) {
    if (!(it.resposta || '').toLowerCase().includes(textAOnly)) return false;
  }
  return true;
};
  const passClass = (it) => (FILTERS.size === 0 || FILTERS.has(it.classificacao));
  const passClient = (it) => {
  if (!CLIENT_FILTERS || CLIENT_FILTERS.size === 0) return true;
  const c = normCode(parseUserId(it.user_id).cliente || '');
  return CLIENT_FILTERS.has(c);
};

const passUnit = (it) => {
  if (!UNIT_FILTER || !CLIENTS_INFO) return true;
  const c = normCode(parseUserId(it.user_id).cliente || '');
  const info = CLIENTS_INFO.get(c) || CLIENTS_INFO.get(normCode(c));
  return info ? (info.unidade === UNIT_FILTER) : true;
};

const matchItem = (it) => passClass(it) && passText(it) && passClient(it) && passUnit(it);

  let filtered = [];
  if (FILTER_MODE === 'items') {
    filtered = DATA.filter(matchItem).sort(compareByGroup);
  } else {
    const matchedGroups = new Set(
      DATA.filter(matchItem).map(it => groupLabelFromCode(it.codigo))
    );
    filtered = DATA
      .filter(it => matchedGroups.has(groupLabelFromCode(it.codigo)) && passText(it))
      .sort(compareByGroup);
  }

  // Totais (sobre o conjunto total)
  const countBy = {};
  for (const r of DATA){ countBy[r.classificacao] = (countBy[r.classificacao]||0)+1; }
  const total = DATA.length || 1;
  const order = ['Correta','Incorreta','Falta de Documentação','Pergunta investigativa','Sem classificação'];
  const classesOrdenadas = [...Object.keys(countBy)].sort((a,b)=>{
    const ia=order.indexOf(a), ib=order.indexOf(b);
    return (ia===-1?99:ia)-(ib===-1?99:ib)||a.localeCompare(b);
  });
  for (const cls of classesOrdenadas){
    const count = countBy[cls], pct = Math.round(count*100/total), dot = colorDotFor(cls);
    const el = document.createElement('div');
    el.className='badge';
    el.innerHTML = `<span class="dot ${dot}"></span><span>${withEmoji(cls)}</span><b>${count}</b><span class="small">(${pct}%)</span>`;
    totals.appendChild(el);
  }

  // Distintos clientes no conjunto filtrado (somente com código válido)
  const distinctClients = new Set(filtered.map(it => parseUserId(it.user_id).cliente).filter(Boolean)).size;
  resultCount.textContent = `${filtered.length} itens • ${distinctClients} cliente${distinctClients===1?'':'s'}`;

  // Cards + divisores por grupo
  let lastGroup = null;
  for (const r of filtered){
    const gLabel = groupLabelFromCode(r.codigo);
    if (gLabel !== lastGroup){
      const sep = document.createElement('div');
      sep.className = 'group-sep';
      sep.innerHTML = `<div class="line"></div><div class="label">Grupo ${gLabel}</div><div class="line"></div>`;
      cards.appendChild(sep);
      lastGroup = gLabel;
    }

    const done = getDone(r.codigo);
    const chipCls = chipClassFor(r.classificacao);

    const card = document.createElement('div');
    card.className='card' + (done ? ' done' : '');

const evalBox = buildEvalBox(r.avaliacao);
card.innerHTML = `
  <div class="card-head">
    <div class="head-left">
      <span class="code">${r.codigo}</span>
      <label class="inline-control" title="Marcar como corrigido">
        <input type="checkbox" class="checkbox mark-done" data-code="${r.codigo}" ${done?'checked':''}>
        <span>Corrigido</span>
      </label>
    </div>
    <div class="head-right">
      <label class="inline-control" title="Alterar classificação">
        <span class="small-label">Classificação</span>
        <select id="sel-${r.codigo}" class="cls-select" data-code="${r.codigo}">
          ${classificationOptionsHTML(r.classificacao)}
        </select>
      </label>

      <div class="cls-chip ${chipCls}">${r.classificacaoEmoji || withEmoji(r.classificacao)}</div>
      <!-- Chip sempre presente; só alternamos .is-on -->
      <div class="corr-chip ${done ? 'is-on' : ''}" data-code="${r.codigo}">Corrigido</div>
    </div>
  </div>

  ${userIdHTML(r.user_id)}
  ${ (r.DATA || r.HORA || r.TOPICOS) ? `
    <div class="small muted" style="margin:-6px 0 6px 0;">
      ${r.DATA ? `<span>Data: ${escapeHtml(r.DATA)}</span>` : ``}
      ${r.HORA ? `<span style="margin-left:10px;">Hora: ${escapeHtml(r.HORA)}</span>` : ``}
      ${r.TOPICOS ? `<span style="margin-left:10px;">Tópicos: ${escapeHtml(r.TOPICOS)}</span>` : ``}
    </div>` : ``}

  <div class="block">
    <div class="block-title">Pergunta</div>
    <div class="block-body">${highlight(escapeHtml(r.pergunta), (SEARCH_Q || SEARCH))}</div>
  </div>

  <div class="block">
    <div class="block-title">Resposta</div>
    <div class="block-body">${highlight(escapeHtml(r.resposta), (SEARCH_A || SEARCH))}</div>
  </div>
`;

    card.appendChild(evalBox);
    cards.appendChild(card);
  }

  // Preenche os nomes dos clientes, quando a planilha estiver configurada
  populateClientNames();

  if ($('#chartWrap').classList.contains('visible')){
    ensurePie(getFiltered());
  }
}

/* Caixa de avaliação */
function buildEvalBox(ev){
  const wrap = document.createElement('div');
  wrap.className='eval';
  const clsTxt = ev?.classificacaoEmoji || withEmoji(ev?.classificacao||'Sem classificação');
  const just = (ev?.justificativa||'').replace(/\n{3,}/g,'\n\n');
  const docs = (ev?.docs||'').replace(/\n{3,}/g,'\n\n');
  const sug  = (ev?.sugestao||'').replace(/\n{3,}/g,'\n\n');

  wrap.innerHTML = `
    <h4>Avaliação do Agente de Curadoria</h4>
    <div class="kv">
      <div class="k">Classificação</div><div class="v">${escapeHtml(clsTxt)}</div>
      <div class="k">Justificativa (curta)</div><div class="v">${escapeHtml(just)}</div>
      <div class="k">Documentos utilizados</div><div class="v">${escapeHtml(docs)}</div>
      <div class="k">Sugestão de melhoria</div><div class="v">${escapeHtml(sug)}</div>
    </div>
  `;
  return wrap;
}

/* ===================== Exportações ===================== */
function getFiltered(){
  const textAll  = (SEARCH   || '').trim().toLowerCase();
const textQOnly= (SEARCH_Q || '').trim().toLowerCase();
const textAOnly= (SEARCH_A || '').trim().toLowerCase();

const passText = (it) => {
  if (textAll) {
    const okAll =
      (it.pergunta || '').toLowerCase().includes(textAll) ||
      (it.resposta || '').toLowerCase().includes(textAll) ||
      (it.codigo   || '').toLowerCase().includes(textAll);
    if (!okAll) return false;
  }
  if (textQOnly) {
    if (!(it.pergunta || '').toLowerCase().includes(textQOnly)) return false;
  }
  if (textAOnly) {
    if (!(it.resposta || '').toLowerCase().includes(textAOnly)) return false;
  }
  return true;
};
  const passClass = (it) => (FILTERS.size === 0 || FILTERS.has(it.classificacao));
  const passClient = (it) => {
    if (!CLIENT_FILTERS || CLIENT_FILTERS.size === 0) return true;
    const c = normCode(parseUserId(it.user_id).cliente || '');
    return CLIENT_FILTERS.has(c);
  };
  const passUnit = (it) => {
    if (!UNIT_FILTER || !CLIENTS_INFO) return true;
    const c = normCode(parseUserId(it.user_id).cliente || '');
    const info = CLIENTS_INFO.get(c) || CLIENTS_INFO.get(normCode(c));
    return !!info && info.unidade === UNIT_FILTER;
  };
  const passTopic = (it) => {
    if (!window.TOPIC_FILTER) return true;
    const tp = String(it.TOPICOS || it.topicos || '').toLowerCase();
    return tp.includes(String(window.TOPIC_FILTER||'').toLowerCase());
  };

  const matchItem = (it) => passClass(it) && passText(it) && passClient(it) && passUnit(it) && passTopic(it);

  if (FILTER_MODE === 'items') {
    return DATA.filter(matchItem).sort(compareByGroup);
  } else {
    const matchedGroups = new Set(
      DATA.filter(matchItem).map(it => groupLabelFromCode(it.codigo))
    );
    return DATA
      .filter(it => matchedGroups.has(groupLabelFromCode(it.codigo)) && passText(it))
      .sort(compareByGroup);
  }
}
function exportCodes(rows){
  const lines = ['codigo'];
  rows.forEach(r=> lines.push(r.codigo));
  download(`codigos_filtrados.csv`, lines.join('\n'));
}
function exportFull(rows){
  const csv = [ ['grupo','codigo','classificacao','pergunta','resposta','justificativa_curta','documentos_utilizados','sugestao_melhoria'].join(';') ];
  rows.forEach(r=>{
    const row = [
      r.grupo||'',
      r.codigo||'',
      r.classificacao||'',
      (r.pergunta||'').replace(/\s+/g,' ').trim(),
      (r.resposta||'').replace(/\s+/g,' ').trim(),
      (r.avaliacao?.justificativa||'').replace(/\s+/g,' ').trim(),
      (r.avaliacao?.docs||'').replace(/\s+/g,' ').trim(),
      (r.avaliacao?.sugestao||'').replace(/\s+/g,' ').trim(),
    ];
    csv.push(row.map(v=>`"${v.replace(/"/g,'""')}"`).join(';'));
  });
  download(`relatorio_completo.csv`, csv.join('\n'));
}

/* ===== Relatório — Conferência (por CLIENTE) ===== */
async function exportConferencia(rows){
  const nameMap = await loadClientMap();
  // Agora agregamos preservando código, nome e grupos distintos
  const agg = new Map(); // codeNorm -> {code,name,label,groups:Set,total,correta,falta,incorreta}
  for (const r of rows){
    const raw  = parseUserId(r.user_id).cliente || '';
    const code = normCode(raw) || 'não identificado';
    const name = nameMap.get(code) || nameMap.get(raw) ||
                 (INTERNAL_LICENSE_CODES.has(code) ? 'Licença Interna' : '');
    const label = (code === 'não identificado') ? code : (name ? `${code} — ${name}` : code);

    if (!agg.has(code)) agg.set(code, { code, name, label, groups:new Set(), total:0, correta:0, falta:0, incorreta:0 });
    const acc = agg.get(code);
    acc.groups.add(groupLabelFromCode(r.codigo));
    acc.total += 1;
    if (r.classificacao === 'Correta') acc.correta += 1;
    else if (r.classificacao === 'Falta de Documentação') acc.falta += 1;
    else if (r.classificacao === 'Incorreta') acc.incorreta += 1;
  }

  // Cabeçalho com colunas separadas + coluna de grupo(s)
  const header = ['grupo','codigo_cliente','cliente','total','corretas','falta_documentacao','incorretas','data','hora'];
  const csv = [ header.join(';') ];

  Array.from(agg.values())
    .sort((a,b)=> String(a.label).localeCompare(String(b.label),'pt-BR',{numeric:true}))
    .forEach(v=>{
      const grupo = Array.from(v.groups).sort((a,b)=>a.localeCompare(b,'pt-BR',{numeric:true})).join(', ');
      const row = [grupo, v.code, v.name || '', v.total, v.correta, v.falta, v.incorreta, '', ''];
      csv.push(row.map(x=>String(x).replace(/"/g,'""')).map(x=>`"${x}"`).join(';'));
    });

  download(`relatorio_conferencia.csv`, csv.join('\n'));
}

/* ===== Modal de Clientes (lista + aplicação do filtro) ===== */
function buildClientEntries(){
  const counts = new Map();
  for (const r of (DATA||[])){
    const raw = parseUserId(r.user_id).cliente || '';
    if (!raw) continue;
    const c = normCode(raw);
    counts.set(c, (counts.get(c)||0)+1);
  }
  return Array.from(counts.entries()).map(([code,count])=>({code,count}));
}
async function fillClientModalList(){
  const listEl = document.getElementById('clientModalList');
  if (!listEl) return;
  const map = await loadClientMap();
  const items = buildClientEntries()
    .sort((a,b)=> String(a.code).localeCompare(String(b.code),'pt-BR',{numeric:true}));
  if (!items.length){
    listEl.innerHTML = '<div class="client-modal__empty">Nenhum cliente encontrado nos dados importados.</div>';
    return;
  }
  const row = (it)=>{
    const name = map.get(it.code) || '';
    const label = name ? `${it.code} — ${name}` : it.code;
    const checked = CLIENT_FILTERS.has(it.code) ? 'checked' : '';
    return `<label class="client-option">
              <input type="checkbox" value="${it.code}" ${checked}>
              <span>${label}</span>
              <small class="small">(${it.count})</small>
            </label>`;
  };
  listEl.innerHTML = items.map(row).join('');
}
function updateClientFilterText(){
  const n = (CLIENT_FILTERS && CLIENT_FILTERS.size) ? CLIENT_FILTERS.size : 0;
  document.querySelectorAll('#btnFilterClient').forEach(btn=>{
    if (!btn) return;
    btn.textContent = n === 0 ? 'Filtrar por cliente'
      : (n === 1 ? `Cliente: ${[...CLIENT_FILTERS][0]}` : `Clientes: ${n}`);
  });
  document.querySelectorAll('#btnClearClients').forEach(clr=>{
    if (clr) clr.disabled = n === 0;
  });
}
async function openClientModal(){
  await fillClientModalList();
  const modal = document.getElementById('clientModal');
  if (modal){ modal.classList.add('open'); }
  const s = document.getElementById('clientModalSearch');
  if (s){ s.value=''; s.focus(); }
}
function closeClientModal(){
  const modal = document.getElementById('clientModal');
  if (modal){ modal.classList.remove('open'); }
}
(function wireClientModal(){
  const modal = document.getElementById('clientModal');
  if (!modal) return;

  // abrir (há 2 botões com o mesmo id no layout)
  document.querySelectorAll('#btnFilterClient').forEach(btn=>{
    btn.addEventListener('click', openClientModal);
  });

  // limpar filtro global
  document.querySelectorAll('#btnClearClients').forEach(btn=>{
    btn.addEventListener('click', ()=>{
      CLIENT_FILTERS.clear();
      updateClientFilterText();
      render();
      fillClientModalList();
    });
  });

  // fechar por backdrop/botão com data-close
  modal.addEventListener('click', (e)=>{ if (e.target && e.target.dataset && e.target.dataset.close){ closeClientModal(); }});

  // aplicar seleção
  document.getElementById('clientModalApply')?.addEventListener('click', ()=>{
    const listEl = document.getElementById('clientModalList');
    const sel = Array.from(listEl.querySelectorAll('input[type="checkbox"]:checked')).map(i=>i.value);
    CLIENT_FILTERS = new Set(sel);
    updateClientFilterText();
    render();          // atualiza a preview com apenas os clientes marcados
    closeClientModal();
  });

  // limpar dentro do modal
  document.getElementById('clientModalClear')?.addEventListener('click', ()=>{
    CLIENT_FILTERS.clear();
    updateClientFilterText();
    render();
    fillClientModalList();
  });

  // busca local na lista
  document.getElementById('clientModalSearch')?.addEventListener('input', (e)=>{
    const q = denoise((e.target.value||'').toLowerCase());
    document.querySelectorAll('#clientModalList .client-option').forEach(opt=>{
      const txt = denoise(opt.textContent||'').toLowerCase();
      opt.style.display = txt.includes(q) ? '' : 'none';
    });
  });
})();

/* ===================== Gráfico (toggle) ===================== */
function computeStats(rows){
  const map = new Map();
  rows.forEach(r=>{ const k = r.classificacao; map.set(k, (map.get(k)||0)+1); });
  const order = ['Correta','Incorreta','Falta de Documentação','Pergunta investigativa','Sem classificação'];
  const labels = [], values = [];
  order.forEach(k=>{ if (map.has(k)){ labels.push(withEmoji(k)); values.push(map.get(k)); } });
  return { labels, values, total: values.reduce((a,b)=>a+b,0) };
}
function buildLegendHTML(labels){
  const list = $('#chartLegendList'); list.innerHTML = '';
  labels.forEach(l=>{
    const li = document.createElement('li');
    li.className = 'legend-item';
    li.innerHTML = `<span class="swatch" style="background:${classColor(l)}"></span><span>${l}</span>`;
    list.appendChild(li);
  });
}
function ensurePie(rows){
  const wrap = $('#chartWrap'); wrap.classList.add('visible');
  const ctx = $('#pieChart').getContext('2d');
  const {labels, values, total} = computeStats(rows);

  if (pieChart){ pieChart.destroy(); }
  buildLegendHTML(labels);
  const bgColors = labels.map(l => classColor(l));

  pieChart = new Chart(ctx, {
    type: 'pie',
    data: { labels, datasets: [{ data: values, backgroundColor: bgColors, borderWidth: 0 } ] },
    options: {
      maintainAspectRatio: false,
      plugins: { legend: { display:false }, tooltip: { enabled: true } }
    }
  });

  const counts = labels.map((l,i)=> `${l}: ${values[i]} (${Math.round(values[i]*100/(total||1))}%)`).join('  •  ');
  $('#chartCounts').textContent = counts;
}
function toggleChart(){
  const wrap = $('#chartWrap');
  const showing = !wrap.classList.contains('visible');
  if (showing){
    ensurePie(getFiltered());
    $('#btnChart').textContent = 'Ocultar gráfico de assertividade';
  }else{
    wrap.classList.remove('visible');
    if (pieChart){ pieChart.destroy(); pieChart = null; }
    $('#btnChart').textContent = 'Exibir gráfico de assertividade';
  }
}

/* ===================== Eventos UI ===================== */
document.getElementById('cards').addEventListener('change', (e)=>{
  if (e.target.classList.contains('mark-done')){
    const code = e.target.getAttribute('data-code');
    const checked = e.target.checked;

    setDone(code, checked);

    const card = e.target.closest('.card');
    card?.classList.toggle('done', checked);

    const corr = card.querySelector('.corr-chip');
corr?.classList.toggle('is-on', checked);

    return;
  }

  if (e.target.classList.contains('cls-select')){
    const code = e.target.getAttribute('data-code');
    const val  = e.target.value;
    const row = DATA.find(d=>d.codigo===code);
    if (row){
      row.classificacao = val;
      row.classificacaoEmoji = withEmoji(val);
    }
    render();
    return;
  }
});

$$('input[name="filterMode"]').forEach(r=>{
  r.addEventListener('change', (e)=>{
    FILTER_MODE = e.target.value;
    render();
  });
});

$('#fileInput').addEventListener('change', async (ev)=>{
  const f = ev.target.files?.[0]; if (!f) return;
  CURRENT_FILE_NAME = f.name || '';
  $('#fileName').textContent = CURRENT_FILE_NAME;
  const raw = await f.text();
  try{ RAW = JSON.parse(raw); }catch{ alert('JSON inválido.'); return; }

  DATA = parseJson(RAW);
  if (!DATA.length){ alert('Nada encontrado. Verifique o formato (grupo/interacoes OU blocos do ASSISTANT com Interação/Pergunta/Resposta).'); return; }

  ALL_CLASSES = Array.from(new Set(DATA.map(d=>d.classificacao))).sort((a,b)=>{
    const prio = ['Correta','Incorreta','Falta de Documentação','Pergunta investigativa','Sem classificação'];
    const ia = prio.indexOf(a), ib = prio.indexOf(b);
    return (ia===-1?99:ia) - (ib===-1?99:ib) || a.localeCompare(b);
  });
    FILTERS.clear();
  buildFilters();
  render();
  // Carrega mapa de clientes e preenche nome + unidade na HOME
  if (typeof loadClientMap === 'function') { loadClientMap().then(()=>{ if (typeof populateClientNames==='function') populateClientNames(); }); }
  // Garante filtros dinâmicos atualizados
  if (typeof refreshUnitFilterOptions==='function') refreshUnitFilterOptions();
  if (typeof ensureTopicFilterUI==='function') ensureTopicFilterUI();
  if (typeof refreshTopicFilterOptions==='function') refreshTopicFilterOptions();

  // Exibe os botões na barra de resultados
const bar = document.querySelector('#totalsPanel .result-bar');
const chartBtn = $('#btnChart');
if (bar && chartBtn){ bar.appendChild(chartBtn); }
$('#btnFilterClient')?.classList.remove('hidden');
$('#btnClearClients')?.classList.remove('hidden');
// Estado inicial dos textos
(function(){
  const btn = document.getElementById('btnFilterClient');
  const clr = document.getElementById('btnClearClients');
  const n = (CLIENT_FILTERS && CLIENT_FILTERS.size) ? CLIENT_FILTERS.size : 0;
  if (btn) btn.textContent = n === 0 ? 'Filtrar por cliente' : (n === 1 ? `Cliente: ${[...CLIENT_FILTERS][0]}` : `Clientes: ${n}`);
  if (clr) clr.disabled = n === 0;
})();

  const wrap = $('#chartWrap'); wrap.classList.remove('visible');
  if (pieChart){ pieChart.destroy(); pieChart = null; }
  $('#btnChart').textContent = 'Exibir gráfico de assertividade';
});

$('#searchBox').addEventListener('input', e=>{ SEARCH = e.target.value||''; render(); });
$('#searchQ').addEventListener('input', e=>{ SEARCH_Q = e.target.value || ''; render(); });
$('#searchA').addEventListener('input', e=>{ SEARCH_A = e.target.value || ''; render(); });
$('#exportConferencia').addEventListener('click', ()=>{
  const rows = getFiltered(); if (!rows.length) return alert('Nada para exportar.');
  exportConferencia(rows);
});
$('#btnChart').addEventListener('click', toggleChart);
$('#btnFilterClient').addEventListener('click', ()=>{ if (typeof openClientModal==='function') openClientModal(); });
$('#btnClearClients')?.addEventListener('click', ()=>{
  CLIENT_FILTERS.clear();
  const btn = document.getElementById('btnFilterClient');
  const clr = document.getElementById('btnClearClients');
  if (btn) btn.textContent = 'Filtrar por cliente';
  if (clr) clr.disabled = true;
  render();
});

/* Modo foco / compacto */
$('#focusBtn').addEventListener('click', ()=>{
  const on = document.body.classList.toggle('focus');
  $('#focusBtn').textContent = on ? 'Sair do foco' : 'Modo Foco';
});
$('#compactBtn').addEventListener('click', ()=>{
  const on = document.body.classList.toggle('compact');
  $('#compactBtn').textContent = on ? 'Sair do compacto' : 'Modo Compacto';
});

/* ===================== Persistência de marcação ===================== */
function safeFileKey(){
  // Usa o nome do arquivo atual; se não houver, cai em "GLOBAL"
  const n = (CURRENT_FILE_NAME || 'GLOBAL').toLowerCase();
  return n.replace(/[^a-z0-9]+/g,'-'); // normaliza
}
function getDoneKey(code){
  // Agora a chave inclui o arquivo para isolar marcações por JSON
  return 'poscuradoria_done_' + safeFileKey() + '_' + code;
}
function getDone(code){
  try{ return localStorage.getItem(getDoneKey(code)) === '1'; }catch(e){ return false; }
}
function setDone(code, on){
  try{ localStorage.setItem(getDoneKey(code), on ? '1' : '0'); }catch(e){}
}
</script>

<script>
/* App switcher */
(function(){
  const wrap  = document.querySelector('.app-switcher');
  const btn   = document.getElementById('appSwitcherBtn');
  const menu  = document.getElementById('appSwitcherMenu');
  if (!wrap || !btn || !menu) return;
  function toggle(open){ wrap.classList.toggle('open', open ?? !wrap.classList.contains('open')); }
  btn.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(); });
  document.addEventListener('click', (e)=>{ if (!wrap.contains(e.target)) toggle(false); });
  document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') toggle(false); });
})();
</script>
<!-- Ajuda (FAB) -->
<div class="help-fab" id="helpFab" aria-live="polite">
  <span class="help-hint" tabindex="0" aria-label="Ajuda: passo a passo" role="button">?</span>
  <div class="help-bubble" role="dialog" aria-modal="false" aria-label="Passo a passo da Curadoria">
    <h4>🧠 <b>Passo a passo da Curadoria</b></h4>

    <p><b>1. Conversor — Preparar os Arquivos</b></p>
    <p>Use este programa para converter documentos da base da Kiara (DOCX, PDF, RTF, etc.) para <b>.TXT</b>. Padroniza conteúdos para envio ao Agente de Curadoria.</p>
    <p><b>Recomendações</b>:</p>
    <ul>
      <li>Converta apenas o que é útil ao treinamento/avaliação.</li>
      <li>Agrupe informações em menos arquivos (evite centenas de arquivos pequenos).</li>
      <li>Depois da conversão, suba os <b>.TXT</b> na Base de Dados do Agente de Curadoria.</li>
    </ul>

    <p style="margin-top:10px"><b>2. Transmissor — Enviar as Interações para Avaliação</b></p>
    <p>Transmita as interações (perguntas e respostas) que serão avaliadas.</p>
    <p><b>Necessário</b>: ID do Bot de Curadoria e <b>API Key</b> (nunca compartilhe).</p>
    <p><b>Como funciona</b>: após preencher os dados e importar o JSON do período, clique em <b>ENVIAR</b>. O Agente inicia a avaliação automaticamente.</p>
    <p class="muted">Dica: transmitir no mesmo dia em que a curadoria será feita.</p>

    <p style="margin-top:10px"><b>3. Workspace — Visualizar as Avaliações</b></p>
    <p>Depois do processamento, o Agente gera um <b>.JSON</b> com as classificações da Kiara.</p>
    <p><b>No Workspace você pode</b>: importar o retorno, visualizar avaliações, e filtrar por <em>Correta, Incorreta, Falta de Documentação</em>…</p>

    <p style="margin-top:10px"><b>Fluxo ideal</b>: Conversor → Transmissor → Workspace</p>
  </div>
</div>

<script>
  (function(){
    const fab = document.getElementById('helpFab');
    if (!fab) return;
    const hint = fab.querySelector('.help-hint');
    const bubble = fab.querySelector('.help-bubble');
    function toggle(open){ fab.classList.toggle('open', open ?? !fab.classList.contains('open')); }
    hint.addEventListener('click', (e)=>{ e.stopPropagation(); toggle(); });
    hint.addEventListener('keydown', (e)=>{ if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); toggle(); }});
    document.addEventListener('click', (e)=>{ if (!fab.contains(e.target)) toggle(false); });
    document.addEventListener('keydown', (e)=>{ if (e.key === 'Escape') toggle(false); });
  })();
</script>

<!-- Modal de clientes (visual alinhado ao app) -->
<div id="clientModal" class="client-modal" aria-hidden="true">
  <div class="client-modal__backdrop" data-close="1"></div>
  <div class="client-modal__panel" role="dialog" aria-modal="true" aria-labelledby="clientModalTitle">
    <div class="client-modal__head">
      <div id="clientModalTitle">Filtrar por cliente</div>
      <button type="button" class="btn" data-close="1">Fechar</button>
    </div>
    <div class="client-modal__body">
      <div class="client-modal__search">
        <input id="clientModalSearch" type="search" placeholder="Buscar cliente por código ou nome">
      </div>
      <div id="clientModalList" class="client-modal__list"></div>
    </div>
    <div class="client-modal__foot">
      <button id="clientModalClear" class="btn" type="button">Limpar</button>
      <button id="clientModalApply" class="btn primary" type="button">Aplicar</button>
    </div>
  </div>
</div>

<script>
// Modal de clientes: constrói lista "código — nome (qtd)" com normalização (sem zeros à esquerda)
(function(){
  function buildEntries(){
    const counts = new Map(); // codeNorm -> qtd
    for (const r of (DATA||[])){
      const raw = parseUserId(r.user_id).cliente || '';
      if (!raw) continue;
      const c = normCode(raw);
      counts.set(c, (counts.get(c)||0)+1);
    }
    return Array.from(counts.entries()).map(([code,count])=>({code,count}));
  }
  async function fillList(){
    const listEl = document.getElementById('clientModalList');
    const map = await loadClientMap();
    const items = buildEntries().sort((a,b)=> String(a.code).localeCompare(String(b.code),'pt-BR',{numeric:true}));
    if (!items.length){
      listEl.innerHTML = '<div class="client-modal__empty">Nenhum cliente encontrado nos dados importados.</div>';
      return;
    }
    const row = (it)=>{
      const name = map.get(it.code) || '';
      const label = name ? `${it.code} — ${name}` : it.code;
      const checked = CLIENT_FILTERS.has(it.code) ? 'checked' : '';
      return `<label class="client-option"><input type="checkbox" value="${it.code}" ${checked}><span>${label}</span><small class="small">(${it.count})</small></label>`;
    };
    listEl.innerHTML = items.map(row).join('');
  }
  function wire(){
    const modal = document.getElementById('clientModal');
    const listEl = document.getElementById('clientModalList');

    modal.addEventListener('click', (e)=>{ if (e.target && e.target.dataset && e.target.dataset.close){ closeClientModal(); }});
    document.getElementById('clientModalClear').addEventListener('click', ()=>{
      CLIENT_FILTERS.clear();
      updateClientFilterText();
      render();
      fillList();
    });
    document.getElementById('clientModalApply').addEventListener('click', ()=>{
      const sel = Array.from(listEl.querySelectorAll('input[type="checkbox"]:checked')).map(i=>i.value);
      CLIENT_FILTERS = new Set(sel);
      updateClientFilterText();
      render();
      closeClientModal();
    });
    document.getElementById('clientModalSearch').addEventListener('input', (e)=>{
      const q = denoise(e.target.value||'').toLowerCase();
      listEl.querySelectorAll('.client-option').forEach(opt=>{
        const txt = denoise(opt.textContent||'').toLowerCase();
        opt.style.display = txt.includes(q) ? '' : 'none';
      });
    });
  }
  window.openClientModal = async function openClientModal(){
    await fillList();
    document.getElementById('clientModal').classList.add('open');
    document.getElementById('clientModalSearch').focus();
  };
  window.closeClientModal = function closeClientModal(){
    document.getElementById('clientModal').classList.remove('open');
  };
  window.updateClientFilterText = function(){
    const btn = document.getElementById('btnFilterClient');
    const clr = document.getElementById('btnClearClients');
    const n = (CLIENT_FILTERS && CLIENT_FILTERS.size) ? CLIENT_FILTERS.size : 0;
    if (btn) btn.textContent = n === 0 ? 'Filtrar por cliente' :
      (n === 1 ? `Cliente: ${[...CLIENT_FILTERS][0]}` : `Clientes: ${n}`);
    if (clr) clr.disabled = n === 0;
  };
  // inicializa handlers do modal
  wire();
})();
</script>
<script>
  // ===== Side Nav – Links reutilizáveis em outros HTMLs =====
  // Opcional: sobrescreva window.APP_LINKS antes deste script em cada app.
  (function(){
    const LINKS = Object.assign({
      workspace:    'https://hdspcorp.github.io/Workspace-Plus/',
      conversor:    'https://hdspcorp.github.io/Conversor-Plus/',
      transmissor:  'https://hdspcorp.github.io/Transmissor-Plus/',
      ajuda:        'LINK_DA_AJUDA',
      current:      'workspace' // qual app marcar como ativo neste arquivo
    }, window.APP_LINKS || {});

    document.querySelectorAll('.side-nav .sn-btn').forEach(a=>{
      const app = a.getAttribute('data-app');
      const href = LINKS[app] || '#';
      a.setAttribute('href', href);
      if (LINKS.current === app) a.classList.add('active');
    });
  })();
</script>
<script>
  // ===== Side Nav – Links e Ajuda ancorada na barra =====
  (function(){
    const LINKS = Object.assign({
      workspace:    'LINK_DO_WORKSPACE',
      conversor:    'LINK_DO_CONVERSOR',
      transmissor:  'LINK_DO_TRANSMISSOR',
      ajuda:        '#',
      current:      'workspace'
    }, window.APP_LINKS || {});

    document.querySelectorAll('.side-nav .sn-btn').forEach(a=>{
      const app = a.getAttribute('data-app');
      const href = LINKS[app] || '#';
      a.setAttribute('href', href);
      if (LINKS.current === app) a.classList.add('active');
    });

    // Ajuda: substitui o FAB flutuante
    const helpBtn = document.querySelector('.side-nav .sn-btn[data-app="ajuda"]');
    const bubble  = document.querySelector('.help-bubble');
    const shell   = document.querySelector('.app-frame');   // container principal
    const nav     = document.querySelector('.side-nav');

    if (helpBtn && bubble && shell && nav){
      const fab = document.querySelector('.help-fab');
      if (fab) fab.style.display = 'none';  // some com o “bubble” do canto inferior direito

      // Move a mensagem para dentro do container e ancora ao lado da barra
      shell.appendChild(bubble);
      bubble.style.position = 'absolute';
      bubble.style.right = 'auto';

      function placeBubble(){
        const left = nav.offsetLeft + nav.offsetWidth + 12; // linha fina + respiro
        bubble.style.left = left + 'px';
        bubble.style.bottom = '24px';
        bubble.style.maxWidth = 'min(560px, calc(100% - ' + (left + 36) + 'px))';
      }
      placeBubble();
      window.addEventListener('resize', placeBubble);

      let open = false;
      helpBtn.addEventListener('click', function(e){
        e.preventDefault();
        open = !open;
        bubble.style.display = open ? 'block' : 'none';
      });
    }
  })();
</script>
<script>
/* Override não intrusivo: mantém o mesmo nome chamado pelo botão */
window.exportConferencia = async function(rows){
  const nameMap = await loadClientMap();

  // Agrega por cliente (código normalizado); coleta grupos vistos
  const agg = new Map();
  for (const r of rows){
    const {cliente} = parseUserId(r.user_id || '');
    const raw  = cliente || '';
    const code = normCode(raw);
    const grp  = groupLabelFromCode(r.codigo);
    const key = raw ? (code || '') : `__anon__:${grp}`;

    if (!agg.has(key)){
      agg.set(key, { raw, code, total:0, corretas:0, falta_documentacao:0, incorretas:0, grupos:new Set() });
    }
    const o = agg.get(key);
    o.total++;
    if (r.classificacao === 'Correta') o.corretas++;
    else if (r.classificacao === 'Falta de Documentação') o.falta_documentacao++;
    else if (r.classificacao === 'Incorreta') o.incorretas++;
    o.grupos.add(grp);
  }

  // Cabeçalho com "grupo" por último
  const header = ['codigo_cliente','cliente','total','corretas','falta_documentacao','incorretas','data','hora','grupo'];
  const lines = [header.join(';')];

  // Ordena por código e resolve nome; cliente ausente → "Cliente não identificado"
  const out = Array.from(agg.values()).sort((a,b)=> String(a.code||'').localeCompare(String(b.code||'')));
  for (const v of out){
    let name = nameMap.get(v.raw) || nameMap.get(v.code) || '';
    if (!v.raw) name = 'Cliente não identificado';
    if (v.code && INTERNAL_LICENSE_CODES && INTERNAL_LICENSE_CODES.has(v.code)) name = 'Licença Interna';
    const grupo = v.raw ? Array.from(v.grupos).sort().join(', ') : (Array.from(v.grupos)[0] || '');
    lines.push([v.code, name, v.total, v.corretas, v.falta_documentacao, v.incorretas, '', '', grupo].join(';'));
  }

  download('relatorio_conferencia.csv', lines.join('\n'));
};
</script>
<script>
/* ===== Navegação local (HOME ↔ ANÁLISE) ===== */
(function(){
  const btnHome = document.getElementById('navHomeBtn');
  const btnAnal = document.getElementById('navAnaliseBtn');
  const panelHome = document.getElementById('resultsPanel');   // painel principal já existente
  const panelAnal = document.getElementById('analysisPanel');  // novo painel

  function showHome(e){ if(e) e.preventDefault();
    if (!panelHome || !panelAnal) return;
    panelAnal.classList.add('hidden');
    panelHome.classList.remove('hidden');
    if (btnHome) btnHome.classList.add('active');
    if (btnAnal) btnAnal.classList.remove('active');
  }
  function showAnalise(e){ if(e) e.preventDefault();
    if (!panelHome || !panelAnal) return;
    panelHome.classList.add('hidden');
    panelAnal.classList.remove('hidden');
    if (btnAnal) btnAnal.classList.add('active');
    if (btnHome) btnHome.classList.remove('active');
  }
  if (btnHome) btnHome.addEventListener('click', showHome);
  if (btnAnal) btnAnal.addEventListener('click', showAnalise);
})();

// === Override de comportamento: Análise troca o botão da seção “Arquivo” e o de Relatórios ===
(function(){
  const lblFile = document.querySelector('label.file-btn[for="fileInput"]');
  const raySideBtn = document.getElementById('rayImportBtnSide');
  const snAnal = document.getElementById('snAnaliseBtn');
  const snHome = document.getElementById('snHomeBtn');
  const panelHome = document.getElementById('resultsPanel');
  const panelAnal = document.getElementById('analysisPanel');
  const rayInp = document.getElementById('rayFileInput');
  const exportBtn = document.getElementById('exportConferencia');

  // Clique no botão lateral “Importar Arquivo RAY” aciona o input real da aba Análise
  // (desativado aqui para evitar handler duplicado; o binding oficial está no bloco “Botões de importação da Análise”)
  if (raySideBtn && rayInp){
    /* noop */
  }

  function clearWorkspaceUI(){
    try{
      const cards = document.getElementById('cards');
      const totals = document.getElementById('totals');
      const resultCount = document.getElementById('resultCount');
      const chartWrap = document.getElementById('chartWrap');
      if (cards) cards.innerHTML = '';
      if (totals) totals.innerHTML = '';
      if (resultCount) resultCount.textContent = '0 itens';
      if (chartWrap) chartWrap.classList.remove('visible');
      if (window.pieChart){ try{ window.pieChart.destroy(); }catch{} window.pieChart = null; }
    }catch{}
  }

  function swapExportButton(forRay){ return; /* desativado: lógica unificada no bloco final (swapExportBtn) */ 
    if (!exportBtn) return;
    const clone = exportBtn.cloneNode(true); // remove handlers antigos
    clone.id = 'exportConferencia';
    if (forRay){
      clone.textContent = 'Exportar CSV RAY';
      clone.dataset.mode = 'analysis';
      clone.disabled = !window.__RAY_READY;
      clone.addEventListener('click', (e)=>{
        e.preventDefault();
        const btnE = document.getElementById('rayExportCsvBtn');
        if (!btnE){ alert('Função de exportação RAY indisponível.'); return; }
        btnE.click();
      });
    }else{
      clone.textContent = 'Relatório de Conferência';
      clone.dataset.mode = 'home';
      clone.disabled = false;
      clone.addEventListener('click', ()=>{
        const rows = (typeof getFiltered==='function') ? getFiltered() : [];
        if (!rows.length) return alert('Nada para exportar.');
        if (typeof exportConferencia==='function') exportConferencia(rows);
      });
    }
    exportBtn.replaceWith(clone);
  }

  function modoHome(){
    if (lblFile) lblFile.classList.remove('hidden');
    if (raySideBtn) raySideBtn.classList.add('hidden');
    if (panelAnal) panelAnal.classList.add('hidden');     // garante que não abre card extra
    if (panelHome) panelHome.classList.remove('hidden');
    swapExportButton(false);
    clearWorkspaceUI(); // recarrega/limpa visual ao alternar
  }
  function modoAnal(){
    if (lblFile) lblFile.classList.add('hidden');
    if (raySideBtn) raySideBtn.classList.remove('hidden');
    if (panelAnal) panelAnal.classList.add('hidden');     // nunca exibe o card de análise
    if (panelHome) panelHome.classList.remove('hidden');
    swapExportButton(true);
    clearWorkspaceUI(); // recarrega/limpa visual ao alternar
  }

  // Captura/override para impedir qualquer handler anterior de abrir o card
  if (snHome) snHome.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); modoHome(); }, true);
  if (snAnal) snAnal.addEventListener('click', (e)=>{ e.preventDefault(); e.stopPropagation(); modoAnal(); }, true);

  // Estado inicial: Home
  modoHome();
})();

/* ===== Utilidades ===== */
function pad2(n){ return String(n).padStart(2,'0'); }
function fmtYMD(d){ return d.getUTCFullYear()+'-'+pad2(d.getUTCMonth()+1)+'-'+pad2(d.getUTCDate()); }
function downloadJSON(filename, obj){
  const blob = new Blob([JSON.stringify(obj, null, 2)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = filename; a.click();
  setTimeout(()=> URL.revokeObjectURL(a.href), 500);
}
/* Converte 'YYYY-MM-DD' em epoch considerando o "relógio local" America/Recife (UTC−3) */
function localRangeUTC(startStr, endStr){
  const [y1,m1,d1] = startStr.split('-').map(Number);
  const [y2,m2,d2] = endStr.split('-').map(Number);
  // Faixa em "tempo local -3" representada em UTC:
  const startUTC = Date.UTC(y1, m1-1, d1, 0, 0, 0, 0);
  const endUTC   = Date.UTC(y2, m2-1, d2, 23, 59, 59, 999);
  return { startUTC, endUTC };
}
/* Aplica -3h em createdAt para comparar no mesmo "relógio" do filtro */
function createdAtLocalEpoch(createdAt){
  const d = new Date(createdAt);
  if (isNaN(d)) return NaN;
  return d.getTime() - 3*60*60*1000;
}

/* ===== Aba ANÁLISE: leitura do arquivo e geração do relatório ===== */
(function(){
  const fileInput = document.getElementById('analysisFile');
  const fileName  = document.getElementById('analysisFileName');
  const genBtn    = document.getElementById('analysisGenerateBtn');
  let ANALYSIS_DATA = null;

  if (fileInput){
    fileInput.addEventListener('change', async ()=>{
      const f = fileInput.files && fileInput.files[0];
      ANALYSIS_DATA = null;
      fileName.textContent = f ? f.name : '';
      if (!f) return;
      try{
        const txt = await f.text();
        ANALYSIS_DATA = JSON.parse(txt);
      }catch(err){
        console.error('Falha ao ler JSON da aba Análise:', err);
        alert('Arquivo inválido. Selecione um JSON válido para a Análise.');
      }
    });
  }

  if (genBtn){
    genBtn.addEventListener('click', ()=>{
      if (!ANALYSIS_DATA){
        alert('Selecione primeiro o JSON de Análise.');
        return;
      }
      try{
        const { startDateStr, endDateStr, conversations } = ANALYSIS_DATA;
        if (!startDateStr || !endDateStr || !Array.isArray(conversations)){
          alert('JSON de Análise sem campos esperados (startDateStr, endDateStr, conversations).');
          return;
        }
        const { startUTC, endUTC } = localRangeUTC(startDateStr, endDateStr);

        // Métricas
        const messagesPerClient = new Map(); // user_id -> contagem de mensagens (user)
        let totalInteractions = 0;
        const clientsSet = new Set();

        // Percorre conversas; considera as mensagens do "user" no intervalo (createdAt -3)
        for (const conv of conversations){
          const uid = (conv && (conv.user_id || conv.anonymous_id || '') ) || '';
          const msgs = Array.isArray(conv?.messages) ? conv.messages : [];
          let userCount = 0;

          for (const m of msgs){
            if (!m || m.role !== 'user' || !m.createdAt) continue;
            const tLocal = createdAtLocalEpoch(m.createdAt);
            if (isNaN(tLocal)) continue;
            if (tLocal >= startUTC && tLocal <= endUTC){
              userCount++;
              totalInteractions++;
            }
          }
          if (userCount > 0){
            clientsSet.add(uid || '(sem user_id)');
            messagesPerClient.set(uid || '(sem user_id)', (messagesPerClient.get(uid || '(sem user_id)')||0) + userCount);
          }
        }

        const report = {
          periodo: { startDateStr, endDateStr },
          totais: {
            clientesDiferentes: clientsSet.size,
            interacoesTotais: totalInteractions
          },
          clientes: Array.from(messagesPerClient.entries()).map(([user_id, mensagens])=>({ user_id, mensagens })),
          geradoEmUTC: new Date().toISOString()
        };

        const fname = `relatorio-conferencia-analise_${fmtYMD(new Date())}.json`;
        downloadJSON(fname, report);
      }catch(err){
        console.error('Erro ao gerar relatório (Análise):', err);
        alert('Ocorreu um erro ao gerar o relatório de conferência da Análise.');
      }
    });
  }
})();
</script>
<script>
/* ===== Navegação – botões do menu lateral ===== */
(function(){
  const homeBtn  = document.getElementById('snHomeBtn');
  const analBtn  = document.getElementById('snAnaliseBtn');
  const panelHome= document.getElementById('resultsPanel');
  const panelAnal= document.getElementById('analysisPanel');
  function showHome(e){ if(e) e.preventDefault(); if(panelAnal) panelAnal.classList.add('hidden'); if(panelHome) panelHome.classList.remove('hidden'); homeBtn?.classList.add('active'); analBtn?.classList.remove('active'); }
  function showAnal(e){ if(e) e.preventDefault(); if(panelHome) panelHome.classList.add('hidden'); if(panelAnal) panelAnal.classList.remove('hidden'); analBtn?.classList.add('active'); homeBtn?.classList.remove('active'); }
  if (homeBtn) homeBtn.addEventListener('click', showHome);
  if (analBtn) analBtn.addEventListener('click', showAnal);
})();

/* ===== Utilitários locais (Aba Análise – RAY) ===== */
function pad2(n){ return String(n).padStart(2,'0'); }
function fmtYMD(d){ return d.getUTCFullYear()+'-'+pad2(d.getUTCMonth()+1)+'-'+pad2(d.getUTCDate()); }
function createdAtLocalEpoch_RAY(iso){ const d = new Date(iso); return isNaN(d)?NaN:(d.getTime() - 3*60*60*1000); }
function localRangeUTC_RAY(startStr, endStr){
  // startDateStr/endDateStr no formato YYYY-MM-DD
  const [y1,m1,d1] = startStr.split('-').map(Number);
  const [y2,m2,d2] = endStr.split('-').map(Number);
  const startUTC = Date.UTC(y1, m1-1, d1, 0,0,0,0);
  const endUTC   = Date.UTC(y2, m2-1, d2, 23,59,59,999);
  return { startUTC, endUTC };
}
function parseUserIdPart(uid){ const m = String(uid||'').trim().match(/^(\d+)\.(.+)$/); return m? m[1] : ''; }

/* ===== Aba ANÁLISE (RAY): importar e exportar CSV ===== */
(function(){
  const inp   = document.getElementById('rayFileInput');
  const btnI  = document.getElementById('rayImportBtn');
  const btnE  = document.getElementById('rayExportCsvBtn');
  const name  = document.getElementById('rayFileName');
  const statusSide = document.getElementById('rayStatusSide');
  const btnExportConferencia = document.getElementById('exportConferencia');

  let RAY_DATA = null;
  window.__RAY_READY = false;

  function setStatus(msg){
    if (statusSide) statusSide.textContent = msg || '';
  }
  function setRayReady(on){
    window.__RAY_READY = !!on;
    if (btnExportConferencia && btnExportConferencia.dataset.mode === 'analysis'){
      btnExportConferencia.disabled = !window.__RAY_READY;
    }
  }

  if (btnI && inp){
  if (!btnI.dataset.rayBound){
    btnI.dataset.rayBound = '1';
    btnI.addEventListener('click', ()=> inp.click());
  }
  if (!inp.dataset.rayBound){
    inp.dataset.rayBound = '1';
    inp.addEventListener('change', async ()=>{
      const f = inp.files?.[0];
      RAY_DATA = null;
      setRayReady(false);
      setStatus('Aguarde, carregando dados...');
      name.textContent = f ? f.name : 'Nenhum arquivo selecionado';
      if (!f){ setStatus(''); return; }
      try{
        const txt = await f.text();
        RAY_DATA = JSON.parse(txt);

        // Validação mínima e pré-carrega o mapa de clientes
        const ok = RAY_DATA && RAY_DATA.startDateStr && RAY_DATA.endDateStr && Array.isArray(RAY_DATA.conversations);
        if (!ok) throw new Error('JSON sem campos esperados.');
        if (typeof loadClientMap === 'function'){ await loadClientMap(); }

        // mensagem lateral removida conforme solicitado anteriormente
        setStatus('');
        setRayReady(true);
      }catch(e){
        console.error('Falha ao ler Arquivo RAY:', e);
        alert('Arquivo RAY inválido. Selecione um JSON válido.');
        setStatus('');
        setRayReady(false);
      }
    });
  }
}

  if (btnE && !btnE.dataset.rayBound){
  btnE.dataset.rayBound = '1';
  btnE.addEventListener('click', async ()=>{
    if (btnE.dataset.exporting === '1') return;            // bloqueio de reentrada
    btnE.dataset.exporting = '1';
    try{
      if (!RAY_DATA){ alert('Antes, use “Importar Arquivo RAY”.'); return; }
      const { startDateStr, endDateStr, conversations } = RAY_DATA;
      if (!startDateStr || !endDateStr || !Array.isArray(conversations)){
        alert('JSON RAY sem campos esperados (startDateStr, endDateStr, conversations).'); return;
      }
      const { startUTC, endUTC } = localRangeUTC_RAY(startDateStr, endDateStr);

      // Contagem por cliente: considera APENAS pares (user no período) → (próximo assistant com score)
      const counts = new Map(); // code -> interações válidas
      const clientsTouched = new Set();

      for (const conv of conversations){
        const uid  = conv?.user_id || conv?.anonymous_id || '';
        const code = (typeof normCode === 'function') ? normCode(parseUserIdPart(uid)) : parseUserIdPart(uid);
        const msgs = Array.isArray(conv?.messages) ? conv.messages : [];
        let validPairs = 0;

        for (let i = 0; i < msgs.length; i++){
          const m = msgs[i];
          if (!m || m.role !== 'user' || !m.createdAt) continue;
          const t = createdAtLocalEpoch_RAY(m.createdAt);
          if (isNaN(t) || t < startUTC || t > endUTC) continue;

          const next = msgs[i+1];
          if (next && next.role === 'assistant' && typeof next.score === 'number'){
            validPairs++;
          }
        }

        if (validPairs > 0){
          counts.set(code, (counts.get(code)||0) + validPairs);
          clientsTouched.add(code || '(sem código)');
        }
      }

      // Mapa de clientes (mesmo mecanismo da Home)
      let map = null;
      if (typeof loadClientMap === 'function'){
        map = await loadClientMap();
      }
      const INTERNAL = (typeof INTERNAL_LICENSE_CODES !== 'undefined') ? INTERNAL_LICENSE_CODES : new Set();

      // CSV: Código, Nome, Interações, Clientes Distintos (apenas na primeira linha), Data (período)
      const distinctCount = clientsTouched.size;
      const dateLabel = (startDateStr === endDateStr) ? startDateStr : (startDateStr + ' – ' + endDateStr);
      const rows = [['Codigo','Cliente','Interacoes','Clientes Distintos','Data']];
      let first = true;
      Array.from(counts.entries())
        .sort(([a],[b]) => (String(a).localeCompare(String(b),'pt-BR')))
        .forEach(([code, qty])=>{
          const nc   = (typeof normCode === 'function') ? normCode(code) : code;
          let name = '';
          if (map){ name = map.get(code) || map.get(nc) || ''; }
          if (nc && INTERNAL.has(nc)) name = 'Licença Interna';
          rows.push([nc, name, String(qty), first ? String(distinctCount) : '', dateLabel]);
          first = false;
        });

      const csv = '\uFEFF' + rows.map(r => r.map(v => {
        const s = String(v ?? '');
        return /[;"\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
      }).join(';')).join('\n');

      const fname = (typeof __RAY_FILE_NAME_OVERRIDE === 'string' && __RAY_FILE_NAME_OVERRIDE)
  ? __RAY_FILE_NAME_OVERRIDE
  : `relatorio-ray_${fmtYMD(new Date())}.csv`;
if (typeof download === 'function'){ download(fname, csv); }
else {
const a = document.createElement('a');
a.href = URL.createObjectURL(new Blob([csv], {type:'text/csv;charset=utf-8'}));
a.download = fname; a.click(); URL.revokeObjectURL(a.href);
}
if (typeof __RAY_FILE_NAME_OVERRIDE === 'string') { __RAY_FILE_NAME_OVERRIDE = ''; }
    }catch(err){
      console.error('Erro ao exportar CSV RAY:', err);
      alert('Ocorreu um erro ao gerar o CSV RAY.');
    }finally{
      btnE.dataset.exporting = '0';
    }
  });
}
          return;
        }
        const { startUTC, endUTC } = localRangeUTC_RAY(startDateStr, endDateStr);

        // Contagem por cliente (somente mensagens role=user no período)
        const counts = new Map(); // code -> mensagens
        const clientsTouched = new Set();

        for (const conv of conversations){
          const uid  = conv?.user_id || conv?.anonymous_id || '';
          const code = (typeof normCode === 'function') ? normCode(parseUserIdPart(uid)) : parseUserIdPart(uid);
          const msgs = Array.isArray(conv?.messages) ? conv.messages : [];
          let userMsgs = 0;
          for (const m of msgs){
            if (!m || m.role !== 'user' || !m.createdAt) continue;
            const t = createdAtLocalEpoch_RAY(m.createdAt);
            if (isNaN(t)) continue;
            if (t >= startUTC && t <= endUTC){ userMsgs++; }
          }
          if (userMsgs > 0){
            counts.set(code, (counts.get(code)||0) + userMsgs);
            clientsTouched.add(code || '(sem código)');
          }
        }

        // Mapa de clientes (código → nome), mesmo mecanismo da Home
        let map = null;
        if (typeof loadClientMap === 'function'){
          map = await loadClientMap();
        }
        const INTERNAL = (typeof INTERNAL_LICENSE_CODES !== 'undefined') ? INTERNAL_LICENSE_CODES : new Set();

        // Monta CSV: inclui UNIDADE após Cliente e coloca "Clientes Distintos" por último
const distinctCount = clientsTouched.size;
const dateLabel = (startDateStr === endDateStr) ? startDateStr : (startDateStr + ' – ' + endDateStr);
const rows = [['Codigo','Cliente','Unidade','Interacoes','Data','Hora','Clientes Distintos']];
let first = true;
Array.from(counts.entries())
  .sort(([a],[b]) => (String(a).localeCompare(String(b),'pt-BR')))
  .forEach(([code, qty])=>{
    const nc   = (typeof normCode === 'function') ? normCode(code) : code;
    let name = '';
    if (map){ name = map.get(code) || map.get(nc) || ''; }
    if (nc && INTERNAL.has(nc)) name = 'Licença Interna';

    // Unidade a partir do CLIENTS_INFO
    let unidade = '';
    try{
      if (typeof CLIENTS_INFO !== 'undefined' && CLIENTS_INFO){
        const info = CLIENTS_INFO.get(code) || CLIENTS_INFO.get(nc);
        if (info && info.unidade) unidade = info.unidade;
      }
    }catch(e){}

    rows.push([nc, name, unidade, String(qty), dateLabel, '', first ? String(distinctCount) : '']);
    first = false;
  });

        const csv = '\uFEFF' + rows.map(r => r.map(v => {
          const s = String(v ?? '');
          return /[;"\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
        }).join(';')).join('\n');

        const fname = (typeof __RAY_FILE_NAME_OVERRIDE === 'string' && __RAY_FILE_NAME_OVERRIDE)
  ? __RAY_FILE_NAME_OVERRIDE
  : `relatorio-ray_${fmtYMD(new Date())}.csv`;
if (typeof download === 'function'){ download(fname, csv); }
else {
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([csv], {type:'text/csv;charset=utf-8'}));
  a.download = fname; a.click(); URL.revokeObjectURL(a.href);
}
      }catch(err){
        console.error('Erro ao exportar CSV RAY:', err);
        alert('Ocorreu um erro ao gerar o CSV RAY.');
      }
    });
  }
})();
/* --- Atualiza opções de Tópicos e Unidades após cada render --- */
(function(){
  if (typeof window.render === 'function' && !window.__renderPatchedFilters){
    window.__renderPatchedFilters = true;
    const _render = window.render;

    function applyHomeMetaStyling(){
  const root = document.getElementById('cards'); if (!root) return;

  // helpers (sem depender da existência do objeto Helpers)
  const H = window.Helpers || {};
  const esc = H.escapeHtml || (s => String(s));
  const fmtDate = H.fmtDatePt || (s => s);
  const fmtTime = H.fmtTimePt || (s => s);

  root.querySelectorAll('.card').forEach(card=>{
    const metas = Array.from(card.querySelectorAll('.meta, .details, .info, .client-id')).filter(Boolean);
    metas.forEach(m=>{
      if (m.dataset.styled==='1') return;

      // remove "/" como separador e separa por <br>
      const raw = m.innerHTML
        .replace(/\s*\/\s*/g, '<br>')
        .split(/<br\s*\/?>/i)
        .map(h=>h.replace(/<[^>]+>/g,'').trim())
        .filter(Boolean);

      if (!raw.length) return;

      const chips = [];
      for (const line of raw){
        const hit = line.match(/^([^:]+):\s*(.*)$/);
        if (!hit) continue;
        const key = hit[1].trim();
        let val = hit[2].trim();

        // normalização de Data/Hora (pt-BR), mantendo apenas visual
        if (/^data$/i.test(key)) { val = fmtDate(val); }
        if (/^hora$/i.test(key)) { val = fmtTime(val); }

        const isTopic = /^t[óo]pico$/i.test(key);
        chips.push(
          `<span class="meta-chip${isTopic?' topic':''}">
             <span class="k">${esc(key)}:</span><span class="v">${esc(val)}</span>
           </span>`
        );
      }

      if (chips.length){
        m.innerHTML = `<div class="meta-chips">${chips.join('')}</div>`;
        m.dataset.styled = '1';
      }
    });
  });
}

    window.render = function(){
      const out = _render.apply(this, arguments);
      try{
        if (typeof refreshTopicFilterOptions === 'function') refreshTopicFilterOptions();
        if (typeof refreshUnitFilterOptions  === 'function') refreshUnitFilterOptions();
        applyHomeMetaStyling();
      }catch(e){}
      return out;
    };
  }
})();
</script>
</body>
</html>
